<html>
<head>
  <title> Dislocation Modeling using GTdef (V_3.2)</title>
  <link rel="stylesheet" href="simple.css" type="text/css">
</head>
<body margin-right="0" bgcolor=lightyellow text=black link=darkblue vlink=black alink=lime>
<table border=0 cellspacing=5 cellpadding=00>
<tr><td align=top>
 <h1 class="left">Dislocation Modeling using GTdef(V_3.2)</h1>
</td></tr>
<tr><td align=top>
<section id="TOC">
<h2 >Sections of the GTdef model</h2>
<font size=-2pt>(Clicking on section heads will return to the Table of Contents)</font>
<H2 >
  <ol>
<li> <a href = "#INTRO"> Basic Introduction</a></li>
<li> <a href = "#DL"> GTdef Code and How to Download it </a></li>
<li> <a href = "#THEORY"> Background Theory</a></li>
<li> <a href = "#INPUT"> The Input File</a></li>
<li> <a href = "#SPF"> Simple Planar Forward Model </a></li>
<li> <a href = "#uslip"> Uniform Slip Model Inversion </a></li>
<li> <a href = "#nslip"> Non-Uniform Slip Model</a></li>
<li> <a href = "#cbt"> Checkerboard Testing </a></li>
<li> <a href = "#RES"> Resolution Spread Evaluation</a></li>
<li> <a href = "#gf"> Ingesting External Green's Functions</a></li>
<li> <a href = "#ref"> References</a></li>
</ol>
</H2>
</section>

<ol>
<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->
<section id="INTRO">
<li> <H2> <a href = "#TOC"> Introduction </a></li>
  <p>Manual developed by <a href="https://eas.gatech.edu/people/murekezi-derrick"> Derrick Murekezi </a> and <a href="http://geophysics.eas.gatech.edu/people/anewman">Andrew Newman</a></p>
</H2>
<br>
<p>
<gr>GTdef</gr> is an implementation of the Okada (1985) dislocation model written by
Lujia Feng, Ting Chen, and Andrew Newman, with codes translated from <gr>disl</gr> (by Peter Cervelli).  Okada (1985) can describe the
surface deformation associated with rectangular dislocations of most orientations,  within
a purely-elastic half-space, however we've further adapted the codes to allow for horizontally layered materials.
Fault planes do require one edge to be horizontal. Dislocations can be described with dip-slip, strike-slip, and/or opening,
and hence can be used to describe a range of processes including earthquake faulting, interseismic
coupling, and planar fluid changes like magmatic dike inflation or groundwater withdrawal.
</p><br><p>
The code is developed so that one could perform both forward models that predict ground deformation
and inverse models that use data with errors and some modeling constraints to predict information about the
source.  The source in either case can be either simple rectangular slips along the plane, orthogonal to it
or some combination of both.</p>

<br>
<b>Requirements</b>: <ol>
  <li> Algorithms are written in Matlab and require the <c>'Parameter estimation'</c> toolbox for inversions.
  <li> If you wish to use parallel processors, your version needs to include <gr>parpool</gr>, which was implemented around 2015.
  <li> For plotting <a href="https://www.generic-mapping-tools.org/">GMT</a> version 5 or 6.</li>
</ol>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "DL">
<li> <h2> <a href = "#TOC"> GTdef Code and How to Download it</a></li>
<ul><b> Current Version </b> : GTDef 3.2 </ul>
<ul><b> Github Repository for Download </b>:
<a href=https://github.gatech.edu/an77/GTDef.git>https://github.gatech.edu/an77/GTDef.git</a> </ul>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "THEORY">
<li> <h2> <a href = "#TOC"> Background Theory</a></li>

<H3>Kinematic Modeling:</H3>
<p> A very brief discussion of kinematic modeling methods used here should exist.  This would include each Okada (1985) analytical models,
  the Wang et al (2003) layered method, and general injestion of Green's functions from other sources.
</p>
  <br>
<H3>Inverse Modeling:</H3>
<p> <gr>GTdef</gr> performs a bounded linear least-squares inversion of Green's functions to define
  the best-fitting set of models to describe a dataset with errors. The program uses the parameter optimization toolbox program called <gr>lsqlin</gr> (<a href=https://www.mathworks.com/help/optim/ug/lsqlin.html>Matlab info on it</a>).
  You can read more about it and general inversion methods from a number of books (including <a href="http://geophysics.eas.gatech.edu/internal/papers/2005/Santamaria/Santamaria_Fratta_DiscreteSignalsInverseProblems_2005.pdf" target=aux2>
  	Santamarina & Fratta, "Discrete Signals and Inverse Problems" [2005]</a>, and <a href="https://www.sciencedirect.com/science/article/pii/B9780123971609000035" target=aux2>Menke, "Geophysical Data Analysis"</a> -- particularly chapters 3 &amp; 4).
</p>  <br>

<p>    While the simplified forward problem exists:<br>
  <p class="right"><c>(1)</c></p>
  <center><c><b> d</b> = <b>Gm</b></c></center>

  where Okada (1985) describes the Green's function, <c><b>G</b></c>, that relates model parameters <c><b>m</b></c>, to the data, <c><b>d</b></c>.
  If data are numerous, and/or model parameters are greater than one, each can be written as a vector of size <c>n</c> and <c>m</c>, with the <c><b>G</b></c> being a matrix sized <c>n x m</c>.
  </p>
  The inversion equation, where we try to solve for model parameters becomes:

  <p class="right"><c>(2)</c></p>
  <center><c><b>Gm</b> = <b> d</b></c></center>

  For a least-squares solution, the simplified inversion becomes:
  <p class="right"><c>(3)</c></p>
  <center><c><b>m</b><sup>est</sup> = [<b>G</b><sup>T</sup><b>G</b>]<sup>-1</sup><b>G</b><sup>T</sup> <b>d</b></c></center>

  Because we expect there to be interdependence between adjacent model patches, we can describe an additional set of equations to apply to the inversion and regularize the final model.
  Every model patch m<sub>i</sub> can describe its model roughness as the Laplacian of that component of slip (e.g. ds, ss, ts).  We will try to minimize that roughness for each slip component of the model, <c><b>s</b></c>, which here will be the same as <c><b>m</b></c>:

  <p class="right"><c>(4)</c></p>
  <center><c><b>d<sub>p</sub></b>= 0 = &kappa;&nabla;<sup>2</sup><b>s</b></c></center>

  where <c><i>&kappa;</i></c> is the smoothing kernel.
  Furthermore, we combine the data weights and errors into a weighting matrix <c><b>W</b></c>.
  Now, incorporating the errors and weighting, the forward problem becomes:

  <p class="right"><c>(5)</c></p>
  <center><c>
  <b> d</b> = <b>Gm</b> =
  <math xmlns = "http://www.w3.org/1998/Math/MathML">
     <mrow>
      <mo>[</mo>
      <mtable display="true">
          <mtr> <mn>W<sub>ii</sub><b>d</b></mn> </mtr>
          <mtr> <mn>0</mn> </mtr>
      </mtable>
      <mo>]</mo>
     <mrow>
  </math>
  =
  <math>
     <mrow>
      <mo>[</mo>
       <mtable display="true">
          <mtr><mn>W<sub>ii</sub><b>G</b></mn></mtr>
  	<mtr><mn>&kappa;&nabla;<sup>2</sup><b>s</b></mn></mtr>
       </mtable>
      <mo>]</mo>
     <mrow>
  </math> <b>m</b></c></center>

  where the data and greens function matrix are now everything in their respective matrices above.
  The diagonal components of the weighting matrix <c>W<sub><i>ii</i></sub> = (<i>w<sub>i</sub></i>)<sup>0.5</sup>/<i>e<sub>i</sub></i></c>,
  which are the per datum weighting <c><i>w<sub>i</sub></i></c> and errors <c><i>e<sub>i</sub></i></c>.

  With <c><b>d</b></c> and <c><b>G</b></c> now containing the smoothing and weighting terms, our model estimate can now be defined as:

  <p class="right"><c>(6)</c></p>
  <center><c><b>m</b><sup>est</sup> = [<b>G</b><sup>T</sup><b>G</b>+ &epsilon;<sup>2</sup><b>I</b>]<sup>-1</sup><b>G</b><sup>T</sup><b>d</b></c></center>

  where <c><math>&epsilon;<sup>2</sup><b>I</b> = &kappa;&nabla;<sup>2<b></sup>s</b></math></c>.
  We can simplify this by defining the Generalized Inverse Matrix:<br>

  <p class="right"><c>(7)</c></p>
  <center><c><b>G</b><sup>-g</sup> = [<b>G</b><sup>T</sup><b>G</b>+ &epsilon;<sup>2</sup><b>I</b>]<sup>-1</sup><b>G</b><sup>T</sup></c></center>

  so:
  <p class="right"><c>(8)</c></p>
  <center><c><b>m</b><sup>est</sup> = <b>G</b><sup>-g</sup><b>d</b></c></center>
  <!--<center><c><b>m</b><sup>est</sup> = [<b>G</b><sup>T</sup><b>W</b><sub>e</sub><b>G</b>]<sup>-1</sup><b>G</b><sup>T</sup><b>W</b><sub>e</sub><b>d</b></c></center>-->

  The above mathematical formulation is modified for the bounded conditions used for the parameter estimation in <gr>lsqlin</gr>,
  including the option of positivity constraints, which make the full formulation much more complicated.
  However, the grouping of terms are important particularly for the development of distributed slip models as input into the solver,
  and for understanding the model resolution matrix and ultimately resolution spread (an estimate of parameter importance).

</p>

</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "INPUT">
<li> <H2> <a href = "#TOC"> The Input File </a> </H2></li>
<p>
The code includes a detailed input file (<a href="files/GTdef_input" target=aux>click here to download/view</a>) that describes the structure of the input file for both the foward and inverse models. The file describes the model parameters and how they differ for different models run. Below we have included snapshots of the input file for each example model.
</p><p>
Ground rules for the input file include:
<ol>
   <li> Model parameters and data are combined in one input file.
   <ol type="a">
      <li> Forward and inverse models are mixed and distinguished by the range [min max]. If parameter min == max (e.g. 0 == 0), then the parameter is fixed
      <li> Output files can be, and are often used as subsequent input files.  For example, an inversion will produce model parameters that you may want to use to predict deformation away from the data that were used in the inversion.
   </ol>
   <li> No specific order is required for specifying parameters
   <li> The first column is important to identify the data type. Flag is not case sensitive.
   <li> Information within parameter rows are all white-space separated.
   <li> All parameters use the same units, defaulting to meters for each length of fault components, slip magnitudes, and measurement data.
   <li> Angles are described in degree
   <li> Depths are too reported in meters and are increasing going into the earth.
   <li> Any line preceded by a hash <c>'#'</c> is treated as a comment and is ignored.
   <li> The only requirements for the most simple input file are at least one fault line, and one 'data' line, describing the parameters for each. All lines are characterized by their first field and the line order does not matter.
</ol>
In the following sections we will further explore parameter characterization within the input file.
</p>

<h3> FAULT characterization: </h3>
Each fault must fall into one of the below 7 categories described by the nature of slip on the fault, fault parameters, external geometries, or simply extrenal Green's functions. A fault line may look like (example shown in above-linked input file):
<div class="code-wrapper"><pre>
#fault type name        lon       lat     z1  z2   len   str   dip     ss     ds   ts     ss0  ssX      ds0  dsX      ts0  tsX    Nd  Ns
fault  1    gnrc-1      -120.2000 38.0000 3e3 15e3 100e3 170.0 25.0    2.5e-3 1.2  0      0    0        1    1.5      0    0      1   1   # inverted only on dip-slip between 1 and 1.5 m
</pre></div>
Depending on the fault type (second column) the fields within the row will vary.
<ul>
  <li> <b>FAULT Types </b> method used to describe fault [1-4], external geometries [5-6], or external Green's functions [7]
  <ul style="list-style: none;">
     <li> 1 = uniformly or distributed slipping fault defined by one endpoint, fault length, and strike (ss ds ts)
     <li> 2 = uniformly or distributed slipping fault defined by two endpoints (ss ds ts)
     <li> 3 = uniformly or distributed slipping fault defined by one endpoint, fault length, and strike (rake rs ts)
     <li> 4 = uniformly or distributed slipping fault defined by two endpoints (rake rs ts)
     <li> 5 = external geometry with (ss ds ts)
     <li> 6 = external geometry with (rake rs ts)
     <li> 7 = external green functions
  </ul>
  Note: distributed slipping faults are followed by subfault definitions; slip values for the main fault are used for unspecified subfaults

  <li>The fault model defines a fault by its location in terms of longitude then latitude (or x then y if using a local coordinate system),
	  its depth, strike and dip, slip parameters, and the number of subfaults within the model.

  <li><b>FAULT Parameters</b> (for fault type 1) <br>
     <li> flt = [ lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX ]
  	<ul>
  	   <li>  lon,lat (or xx,yy) - one endpoint describing the surface projection of the faults in either geographic (default), or a local cartesian coordinate system
  	   <li>   z1  - vertical burial depth, describing top of slipping portion of fault  [&ge;0]
  	   <li>   z2  - vertical locking depth, describing the bottom of slipping fault  [&ge;0]
  	   <li>   len - fault length [≥0]
  	   <li>   str - strike from the endpoint describe above (degree CW from N) [0-360]
  	   <li>   dip - downward from horizontal, and right looking in the strike-direction [0-180]
  	   <li>   ss  - strike-slip motion (left-lateral +)
  	   <li>   ds  - dip-slip motion (thrust +)
  	   <li>   ts  - tensile motion (opening +)
  	   <li>   ss0,ds0,ts0 - lower bounds for slips
  	   <li>   ssX,dsX,tsX - upper bounds for slips
  	   <li>   nd,ns - number of subfaults along-dip, and along-strike
  	</ul>
</ul>
<h3> Data characterization: </h3>
Every input file needs to desribe either real data, or points in which you want to predict the surface motions.  Each data line begins with its unique identifying name describe below.
A data line for 3-component GPS point data may look like (also from above-linked input file):
<div class="code-wrapper"><pre>
#point type name    lon       lat     z            Ue   Un   Uv      eUe  eUn  eUv	weight
point  3    rdom    -118.8979 37.6770 2417.4049    9.6  1.1  36.1    1.0  1.0  1.3	1
</pre></div>
<ul>
  <li><b>Data Types</b> <br>
	Depending on data type both the data type identifier (first column) and the data-type number (second column) will change as described below..
   <ul>
	   <li>point - data described at a single point at the surface (e.g. GPS).<br>
		   Point-types are:
		<ul style="list-style: none;">
		  <li>1 = vertical component only
		  <li>2 = east, and north components
		  <li>3 = east, north, and vertical components
		</ul>
	    <li>los - a 1-D data point of arbitrary orientation (e.g. line-of-site to SAR satellite).<br>
		   LOS-types are:
		<ul style="list-style: none;">
		  <li>1 = displacement in direction of LOS (e.g. toward satellite)
		  <li>2 = phase change in LOS direction (not implemented yet)
		</ul>
	    <li>baseline - a baseline defined between two sites.<br>
		 baseline-types are:
		<ul style="list-style: none;">
		  <li>1 = length change only
		  <li>2 = east, north, and vertical components
		  <li>3 = east, north, vertical,and length change components
      </ul>
	<hr> <!-- -------------------------------------------------------------------- -->
	<li>profile - a line defined by two endpoints with evenly distributed data points.
	<li>grid - a parallelogram defined by the lower-left (lon1,lat1) and upper-right (lon2,lat2) corners with data points parallel to the sides.
   </ul>
 Note: profile and grid are generally used for displaying results from a forward model.
   <li><b>Data Parameters</b><br>
	   The data-types described above will use differing parameters. Their meaning  and convention are describe here.
	<ul>
	   <li>lon(x),lat(y),z - horizontal location and elevation (positive upward) [m]
	   <li>Erot,Nrot - rotation angles for the East and North axis of grid [degree; + CW] (-90 90)
	   <li>Ue,Un,Uv - surface displacements in East, North, and Vertical directions [m]
	   <li>Ul - length change between two sites [m]
	   <li>ULOS - surface displacement in LOS direction [m]
	   <li>eUe,eUn,eUv,eUl  - standard error for displacements and length change [m]
	   <li>eULOS - standard error for surface displacement in LOS direction [m]
	   <li>LOSdirE,LOSdirN,LOSdirV - unit vector pointing from the ground toward the satellite (LOS direction)
	   <li>N,Ne,Nn - number of data points, and number of columns and rows
	   <li>wavelength - wavelength of signal for LOS (1/2 the SAR satellite natural wavelength)[not yet implemented]
	   <li>weight - weight for incorperating different type of data {1}
	</ul>
<!--  	<li> Xin - point site locations in the local cartesian system
  	<li>       [n*3] [ xx yy zz ]
  	<li> Lin - los point locations in the local cartesian system + los direction
  	<li>       [n*6] [xx yy zz dirE dirN dirV]
  	<li> Bin - baseline site locations in the local cartesian system
  	<li>       [n*6] [ x1 y1 z1 x2 y2 z2 ]
  	<li> Nin - grid and profile node locations in the local cartesian system
  	<li>       [n*3] [ xx yy zz ]
  	<li> Note: z1,z2 depth positive downward
		<li>       zz elevation positive upward -->
</ul>
<h3> Other Model Parameters: </h3>
To be desribed (e.g. coord, smooth, greensfns, matfile, resolution)
<ul>
</ul>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "SPF">
<li> <H2> <a href = "#TOC">Simple Planar Forward Model</a> </H2></li>
<p>
We'll start with the most straight-forward case of a single vertical fault plane with strike-slip motion on the interface.
</p>
<h3> Example Forward Model Run: </h3>
The simplist model includes just one fault and one data-point ran in a forward sense to prediction deformation at that data-point.  We will not stray significantly from there.<br>

<H4>Input:</H4>
 <ol type="i">
 <li> We will create a vertical planar fault approximately 20 km long, with 1 meter, strike-slip motion, buried between 5 and 15 km depth. The output will describe the spatial deformation every 2 km across a 60x60 km grid surrounding the fault.
	 <li> To keep the algorithm from attempting an inversion, it is important that all slip parameter ranges for a given slip-type on a fault block have equal value (i.e. ss0=ssX, ds0=dsX, and ts0=tsX in this example).
 <li> If all range values are set to zero <c>'0'</c>, the initial value will be used. Here, we will have 1m of left-lateral (+) strike-slip that will not vary (all range parameters are set to zero).
 <li> Input files should all end in <c>.in</c>
 <li> The input file can be created in your favorite text-editor (e.g. vim). For simplicity here, we'll just direct stdout from an echo-command into a file called <c>local1.in</c>. The <c>%</c> represents a shell prompt.
<div class="code-wrapper"> <pre>
% echo "
coord local <c># otherwise it will expect geographic coordinates</c>
<c>#fault type name       lon1 lat1   lon2  lat2  z1  z2    dip  ss  ds ts ss0 ssX ds0  dsX  ts0  tsX   Nd  Ns</c>
fault  2    myfault    0   -10e3   0     10e3  5e3 15e3  90   1   0  0  0   0   0    0    0    0     1   1
<c>#grid name    Erot Nrot lon1(x1) lat1(y1) lon2(x2) lat2(y2) Ne Nn</c>
grid  1kmx1km 0    0    -30e3    -30e3    30e3     30e3     31 31
" > local1.in
</pre></div>
</ol>
<h4>Run:</h4>
 <ol type="i">
<li> To run <gr>GTdef</gr>, you must call up matlab (interactive and gui are not necessary).
	<li> Be sure the current version of GTdef is in your path.  You can check this using the <gr>path</gr> function, and add it using <gr>addpath</gr>.
<div class="code-wrapper"> <pre>
<c> # within matlab</c>
> addpath('/path/to/GTdef/v3.2/unstable/') <c>%replacing with your actual path</c>
</pre></div>
<li> The processing code that oversees both forward and inverse models is <gr>GTdef</gr> and is called with just the input file name, and optionally, the number of processors you'd like it to use on your machine. By default, it will use all available processors if not defined.
<div class="code-wrapper"> <pre>
<c> # within matlab</c>
> GTdef('local1.in',1) <c>% will run on '1' core.
</pre></div>
</ol>
<h4>Output:</h4>
<ol type="i">
	<li> This will create an output file called <c>'local1_fwd.out'</c> that will repeat the model, and give predicted results for the defined grid locations (now as <c>'point'</c> data-type).

<li> Quick and dirty visualization can easily be achieved using the freely available gnuplot program.  This allows us to look at the full 3D vector field.
<div class="code-wrapper"> <pre>
 <c># first comment out all lines that are not output data using vim or similar. (not shown)</c>
 % gnuplot
   gnuplot>  set ticslevel 0.0 <c># removes empty whitespace below plot </c>
   gnuplot>  splot 'local1_fwd.out' u 4:5:(0):($7*1e5):($8*1e5):($9*1e5) w vect t "surface displacement" <c> # just the surface results amplified to see variability</c>
   <c>#If you're more adventurous, you can plot the fault too (this assumes the fault is vertically dipping).</c>
   gnuplot>  splot "&lt; awk '$1==\"point\"{print $0}' local1_fwd.out" u 4:5:(0):($7*1e5):($8*1e5):($9*1e5) w vect t "surface displacement",\
   "&lt; awk '$1==\"fault\"{printf \"%f %f %f\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n\", $4,$5,-$8,$6,$7,-$8,$6,$7,-$9,$4,$5,-$9,$4,$5,-$8}' local1_fwd.out" w l lw 2 lt -1 t "fault"
 <c> # use the cursor to move around the data</c>
</pre></div>
<center>
 <img src="files/local1_fwd.png">
</ol>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "uslip">
<li> <H2> <a href = "#TOC"> Uniform Slip Model Inversion: </a> </H2></li>

<h3>Input File:</h3>
We will need to build the model, including gathering the appropriate data and then estabishing an appropriate a priori interface. In this example, we will use the very small tsunami earthquake described in <a href="http://geophysics.eas.gatech.edu/people/anewman/research/papers/Newman_etal_GJI_2011.pdf">Newman et al. (2011)</a>.

<ol type="i">
	<li><b>Data:</b> Here, we pull coastal subsidence data from sheet 3 of the
	<a href="http://geophysics.eas.gatech.edu/people/anewman/research/data/Newman_etal_GJI_2011_Subsidence_and_Tsunami_Data.xls">excel spreadsheet</a>.
	The data, being just vertical uplift/subsidence data need to be convert into the '<c>point 1</c>' format in <gr>GTdef</gr>.
	Errors are estimated to be approximately 0.1 m on all data (assuming error in tidal correction and prior high-tide estimates),
	Because all data were measured using the same methods and likely have similar error values, we choose to give them all equal weight.

<div class="code-wrapper"> <pre>
<c>#point type name                        lon             lat        z    Uv     eUv   weight</c>
point 1  Rendova-Rendova_Harbor         157.33602       -8.40359   0.0  -0.15  0.10  1.0
point 1  Rendova-Epata_Creek            157.30622       -8.43730   0.0  0      0.10  1.0
point 1  Rendova-Mbaniata               157.26260       -8.63325   0.0  -0.70  0.10  1.0
point 1  Rendova-Hofofo_Pt              157.19633       -8.56530   0.0  0      0.10  1.0
point 1  Rendova-Habila                 157.22920       -8.60414   0.0  -0.60  0.10  1.0
point 1  Rendova-Rava_Pt                157.40336       -8.72264   0.0  -0.60  0.10  1.0
point 1  Tetepare-Tofa                  157.53432       -8.75576   0.0  -0.40  0.10  1.0
point 1  Tetepare-Jetty_near_Ecolodge   157.44286       -8.72234   0.0  -0.25  0.10  1.0
point 1  Tetepare-Ecolodge_boat_ramp    157.44321       -8.72120   0.0  -0.30  0.10  1.0
point 1  Rendova-Rano                   157.32886       -8.62969   0.0  -0.50  0.10  1.0
point 1  Rendova-Vankuva                157.33953       -8.60934   0.0  0      0.10  1.0
point 1  Rendova-Kofi_Bay_village       157.33874       -8.6039    0.0  -0.40  0.10  1.0
point 1  Rendova-Mauru_Loging_Camp      157.39881       -8.5137    0.0  -0.30  0.10  1.0
point 1  Rendova-Ugele                  157.39921       -8.44959   0.0  0      0.10  1.0
</pre></div>

<li><p><b>Modeled Fault:</b> We need to come up with a choice for the appropriate input model.  This can be done using existing published fault geometries, evaluating distributions of microseismicity, focal mechanisms, examination of surface topography/bathymetry, or some combination of these methods.  Once an initial model is chosen, output from a number of inversions using differing geometries can be used to chose an optimal geometry by evaluating each geometry's overall model fit. The output results of these inversions can then be broken up into distributed models (discussed below).
	Here, Newman et al. (2011) defined the fault using a combination of the overall fault strike, and testing a range of dip geometries. </p>
<br>
<p>
For our inversion, we will define a finite range of allowble thrust(+) values (<c>ds</c>, and <c>dX</c> between 0 and 100 m).
Because data here are only vertical, we will chose to set strike-slip to 0 and not allow it to vary in the model, as this component will be very poorly constrained, possibly being dependent on choice of geometry. Finally, because this is a uniform slip model, the number of slip and strike components must be set to one (<c>Nd=Ns=1</c>).
	</p>
	<p><i>Note:</i> Here, the dip =158&deg; for a strike of 125&deg;. This is equivelent to a dip of 22&deg; striking 305&deg;, but from the far end-point.</p>
<div class="code-wrapper"> <pre>
<c>#fault type name lon      lat     z1  z2   len   str   dip   ss ds ts ss0 ssX ds0 dsX  ts0 tsX  Nd  Ns </c>
fault  1    slm  157.0990 -8.6920 0   5200 50000 125.0 158.0 0 0.1 0  0   0   0   100  0   0    1   1
</pre></div>
<li><b>Run:</b> After combining the above parameters into a single input file (e.g. '<c>solomon.in</c>'), you can run the code just as was done in the forward model.
</ol>


<H3>Output:</H3>
<ol type="i">
	<li> <b>Output files:</b> If the model converges, you can analyze the output results in either the '<c>_inv.out</c>' or '<c>_kp*.out</c>'.
	The former file gives the fit results of the run, while the later gives the model results as well as their predicted displacements at the sites described in the orginal input model. Its this second file that can be used as an input for future runs.
	<ul>
		<li><b> Model fit:</b> Below is the output from '<c>solomon_inv.out</c>' created by <gr>GTdef</gr>. Since there is only one inversion ran, there will be only one data line following a header line preceded by its column number (#).
		<div class="code-wrapper"> <pre>
<c>#(1)beta (2)kappa (3)data_num (4)slip_num (5)ndf (6)rss [m^2] (7)rms [m] (8)wrrs [m^2] (9)wrms [m] (10)chi2 (11)rchi2 (12)r_1d [cm/km] (13)r_2d [cm/km^2] (14)strain [cm/km]</c>
0.00000e+00  0.00000e+00      14 1 13 4.05607e-01  1.70211e-01   4.05607e+01   1.70211e+00   4.05607e+01   3.12005e+00   NaN           NaN           NaN </pre></div>

			<li><b> Model results and predicted displacements:</b> Shown here is the output from '<c>solomon_kp0.00000.out</c>'.  Note that in addition to lines repeating the input file, there are several default input options explicitely written out here (e.g. coord, earth, surface).  Also included are model misfits repeated from the above file.  Lastly, the model line now includes the model output for a best-fit (showing 5.16091 m of thrust), and the model predictions for each data line (e.g. Rendova-Mbaniata predicts 62.62 cm of subsidence).Though data type was input as <c>point 1</c>, they are output as <c>point 3</c>, giving the predicted horizontal motions as well. Errors are not reported for models.
		<div class="code-wrapper"> <pre>coord   	geo
#data_num	14
#slip_num	1
#ndf     	13
#rss      	4.05607e-01  [m^2]
#rms      	1.70211e-01  [m]
#wrss   	4.05607e+01  [m^2]
#wrms   	1.70211e+00  [m]
#chi2    	4.05607e+01
#rchi2   	3.12005e+00
#r_1d   	NaN          [cm/km]
#r_2d   	NaN          [cm/km^2]
#strain   	NaN          [cm/km]

earth	homogeneous	3.00e+10  	0.2500

kappa   	0.00000
beta     	0.00000

smooth   	2d
surface  	free

fault 1 slm  157.09900000   -8.69200000  0.0000e+00   5.2000e+03 5.0000e+04   125.00 158.00     0.00000 5.16091  0.00000   0.0000 0.0000  0.0000 100.0000  0.0000 0.0000    1 1
point 3 Rendova-Rendova_Harbor	  157.33602000  -8.40359000  0.00000e+00    -0.09951   -0.25301    0.00474         NaN        NaN        NaN  1.00
point 3 Rendova-Epata_Creek	  157.30622000  -8.43730000  0.00000e+00    -0.11693   -0.31236   -0.00387         NaN        NaN        NaN  1.00
point 3 Rendova-Mbaniata	  157.26260000  -8.63325000  0.00000e+00    -0.89590   -1.40681   -0.62620         NaN        NaN        NaN  1.00
point 3 Rendova-Hofofo_Pt	  157.19633000  -8.56530000  0.00000e+00    -0.26215   -0.92622   -0.30033         NaN        NaN        NaN  1.00
point 3 Rendova-Habila	  157.22920000  -8.60414000  0.00000e+00    -0.70254   -1.31715   -0.55581         NaN        NaN        NaN  1.00
point 3 Rendova-Rava_Pt	  157.40336000  -8.72264000  0.00000e+00    -0.98978   -1.39069   -0.60162         NaN        NaN        NaN  1.00
point 3 Tetepare-Tofa	  157.53432000  -8.75576000  0.00000e+00    -0.71027   -0.73619   -0.19750         NaN        NaN        NaN  1.00
point 3 Tetepare-Jetty_near_Ecolodge	  157.44286000  -8.72234000  0.00000e+00    -0.87663   -1.18799   -0.39089         NaN        NaN        NaN  1.00
point 3 Tetepare-Ecolodge_boat_ramp	  157.44321000  -8.72120000  0.00000e+00    -0.86957   -1.17774   -0.38133         NaN        NaN        NaN  1.00
point 3 Rendova-Rano	  157.32886000  -8.62969000  0.00000e+00    -0.73815   -1.12756   -0.30286         NaN        NaN        NaN  1.00
point 3 Rendova-Vankuva	  157.33953000  -8.60934000  0.00000e+00    -0.59654   -0.93641   -0.17707         NaN        NaN        NaN  1.00
point 3 Rendova-Kofi_Bay_village	  157.33874000  -8.60390000  0.00000e+00    -0.57048   -0.90517   -0.16057         NaN        NaN        NaN  1.00
point 3 Rendova-Mauru_Loging_Camp	  157.39881000  -8.51370000  0.00000e+00    -0.24266   -0.41934   -0.00177         NaN        NaN        NaN  1.00
point 3 Rendova-Ugele	  157.39921000  -8.44959000  0.00000e+00    -0.15468   -0.29970    0.00941         NaN        NaN        NaN  1.00 </pre></div>
</ul>

<li><b>Predicting displacements elsewhere:</b> To estimate model displacements outside of the original data points in '<c>_kp*.out</c>', you can copy the model output into a new file along with the points that you want prediced.  Here, we are just using a grid, similar in the foward model example above, name it something like '<c>solomon_fwd.in</c>', and run as before.

<div class="code-wrapper"> <pre> <c>#fault type name lon      lat      z1         z2       len        str    dip     ss    ds     ts      ss0   ssX    ds0   dsX   ts0   tsX    Nd  Ns </c>
fault 1    slm  157.09896 -8.69204 0.00e+00   5.20e+03 5.00e+04   125.00 158.00  0.000 5.167  0.000   0.00  0.00   0.00  0.00  0.00  0.00   1   1
<c>#grid name        Erot Nrot lon1    lat1    lon2     lat2     Ne    Nn   </c>
grid  Solom_region   0    0    156.4   -9.3    158.1    -7.9     200   200 </pre></div>

<li><b>Plotting results:</b> One tool that is particularly useful is the supplied algorithm '<gr>GTdef_project</gr>', as it can take the predicted output model and transform it into a highly-readable file for your favorite plotting program.
<div class="code-wrapper"> <pre>> <c>% within matlab</c>
> GTdef_project('solomon_kp0.00000.out') </pre></div>

	This creates a new file (here '<c>solomon_kp0.00000_patches.out</c>') that describes all elements (here only one) of the model, including geographic position of corners, the element center position, and slip values.
	While you could use a more full-featured plotting program like <a href="#INTRO">GMT</a>, we'll again use <gr>gnuplot</gr> for our quick and dirty plot to show the predicted displacements from '<c>_kp*.out</c>', and then model geometry from '<c>_kp*_patches.out</c>'.
<div class="code-wrapper"> <pre>
<c># within gnuplot </c>
<c># Note: We are using diffential scaling of the displacement vectors to scale with the geographic position and depth (in degrees&deg; and km) </c>
gnuplot> splot "&lt; awk '$1==\"point\"{print $0}' solomon_kp0.00000.out"\
u 4:5:(0):($7*1e-1):($8*1e-1):($9*1e1) w vect t "surface displacement",\
"&lt; awk '$1==\"slm\"{printf \"%f %f %f\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n\", $4,$5,-$6/1000,$7,$8,-$9/1000,$10,$11,-$12/1000,$13,$14,-$15/1000,$4,$5,-$6/1000}' solomon_kp0.00000_patches.out"\
w l lw 4 lt 7 -8 t "fault" </pre></div>
After using your pointer to move around your model appropriately, your result should look something like this:
 <center>
   <img src="files/solomon_single_fault_inv.png" width="700px">
</ol>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "nslip">
<li> <h2> <a href = "#TOC"> Non-uniform Slip Model Inversion: </a> </h2></li>
		<p> This problem is a little more tricky, as we will quickly go from an overdetermined problem (more data than model paremeters),
		     to an underdetermined problem.
		     In order to get around this, and to solve for realistic slip, we constrain the interdependence between individual slip patches.
		    The most popular way to do this is to define minimize the 'roughness' of the slip patch, as defined in
		    <a href=http://geophysics.eas.gatech.edu/internal/papers/1987/Harris/Harris_Segall_JGR_1987.pdf>Harris and Segall (1987)</a>,
 		     but more concisely in <a href=http://geophysics.eas.gatech.edu/internal/papers/2002/J%f3nsson/J%f3nsson_etal_BSSA_2002.pdf>Jónsson_et al_(2002)</a>.
		     <br>
		     The method works to minimize the 2D second-order derivative of the slip surface so that large changes are constrained within a certain value.
		     The way it's been implemented here is that a series of roughness solutions are determined, all yielding different misfits to the data.
		     It is a somewhat arbitrary decision to chose the optimal roughness parameter.  Usually this is done by evaluating the kink-point by which
		     additionally smooth results significantly increase misfits.
  <ol type="i">
		<li> Choose your kappa value (parameter that controls roughness) to range between 0 to 5000 by 500.
<div class="code-wrapper"> <pre>
kappa 2 0  5000 11
</pre></div>
		<li> Setup your fault to now have 70 subfaults, 7 patches along-strike and 10 patches along-dip.
<div class="code-wrapper"> <pre>
<c>#fault type name   lon       lat     z1  z2    len    str    dip     ss   ds    ts    ss0  ssX    ds0  dsX    ts0 tsX    Nd  Ns</c>
 fault  1   slm    157.0990  -8.6920  0  5200  50000  305.0  22.0   0    0.1   0     0    0      0    100    0   0      7   10
</pre> </div>
		<li> Invert and explore your results.  Using <a href="plotting/misfit_kappa.gmt"> misfit_kappa.gmt</a>, try plotting misfit vs. roughness to see how your choices in kappa affect these results. Looking at the L-curve, the 4th lowest kappa value is optimal for this example data set.
      <center> <img src="files/misfit_kappa_solomon_inv.png" width="700px"> </center>
      <li> You might want to look at your results in a geographic reference system.  I've created a GMT script (<a href="plotting/slipmodel.gmt">slipmodel.gmt</a>) to do this,
           but you must modify it for your purposes.
		<li> Finally, once you've chosen your optimal kappa value, run a new forward model, and repredict deformation.
		     <br><br>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "cbt">
<li> <h2> <a href = "#TOC"> Checkerboard Testing: </a> </h2></li>

  <H3>Develop a Synthetic Forward Model:</H3>
    <ol type="i">
    <li> Define the size boxes that you will want to try to recreate in your checkerboards.
      As a general rule, we find that the model patch size that you can interpret is dependent on and about equal to its depth relative to stations overhead.
      This assumes stations are immediately overhead.
      This will certainly change as a function fault dip, and station coverage, thus while you may have theoretical fidelity to recover even extremely small
      patches near the trench (where the fault is just below you), you may not have data until you're on land, 50 to 200 km away.
      Thus, we will take an initial example of a fault patch that is 50 km laterally from a 20&#176; dipping fault surface,
      the checkerboard patch should be around <c> 50km*sin(20&#176;)=17km </c>. At 100 km, it's about <r>34 km</r>, and at  200 km it's about <r>70 km</r>, assuming constant dip.
      Note, that this is just a starting and approximate parameter.

    <li> You will now need to define a number of subfaults that match your expected optimal resolution.
      This too can be done by hand, but the program, <gr>GTdef_ckbd_subflt.m</gr> makes it much easier.
       Check out the header notes within the program for details.

    <li> For a fault named 'nicoya' with 30x40 patches and approximately 200 km x 200 km in size,
      you can run
      <div class="code-wrapper"> <pre>
        <c>% within matlab</c>
        GTdef_ckbd_subflt('nicoya',30,40,3,4, [0 -.0823 0  0 0 0 0 0 0],[0 0 0  0 0 0 0 0 0])</pre></div>
      to define a fault that groups alternating blocks into 3 along dip, and 4 along strike patches. Here, the
      the blocks are 20x20 km (smallest size for coastal data--this is too small for deeper patches).
      The vectors here define the forward behavior of the patches that we normally think of as 1's and 0's.
      So, patch 1 (the black, or slipping patch), p1= is only backthrust at 82.3 mm (no inversion set for these patches).
      For patch 0 (the white, or null patch), p0= zeros (9 of them).
      The program will create a file called <c>GTdef_ckbd_subflt.out</c> that will only contain the sub-fault parameters.
      This will need to be copied into your input model file that contains your fault characterization
      and 'points' in which you want to predict deformation for the forward run.
      <div class="code-wrapper"> <pre>
        <c># in shell (command line)</c>
        cat GTdef_ckbd_subflt.out >> nicoya_ckbd.in</pre></div>
    <li> Once it's ready, run
      <div class="code-wrapper"> <pre>
        <c>% within matlab</c>
        GTdef('nicoya_ckbd.in')</pre></div>
   If everything works you will get your initial noise-free synthetics.

   <li>Using <gr>GTdef_slipmodel.gmt</gr>, plot the noise free model with the <c>nicoya_ckbd_fwd.out</c>
   (the output from the forward run). Running the code without options will give brief usage information.
   <div class="code-wrapper"> <pre>
     <c># in shell (command line)</c>
     GTdef_slipmodel.gmt -M nicoya_ckbd.in -S100/100/10</pre></div>

   The figure should look like the example below.
       <center><img src="files/GTdef_slipmodel_nicoya_ckbd_fwd.png" width="700px"></center>
       Note, that because this program is written for real data, the labeling may not be accurate.  Here, 'observed' is arbitrary, and
       whatever was in your original input file.  Modeled data are the predicted results that will be used for subsequent inversions.
    </ol>



  <H3>Adding Noise: </H3>
    <p>Good synthetic data includes an approximation of the noise that you'd get in the real data.
      For this, We've developed a simple shell script that searches only point data from an output
      file and adds Gaussian noise to the data itself.
      The program then writes out the perturbed data and error estimates representing the input error,
      of the size defined <u>within</u> the script.
      This program needs updating for easier and general use, but it's pretty easy to run, as is.  </p>
    <ol type= "i">
      <li> Copy the program to your working directory (its called <gr> add_noise.sh </gr> and is in the
        plotting directory shared with the GTdef scripts).
      <li> Edit the parameters at the top of the file to include the expected
        East, North, and Vertical noise in your data (in meters).
        Now run it it on the output file, directing into a new output.
        As an example:
        <div class="code-wrapper"> <pre>
        <c># in shell (command line)</c>
        add_noise.sh nicoya_ckbd_fwd.out > nicoya_ckbd_fwd_wNOISE.in</pre></div>
        Note that the directed output is now ending in <c>'.in'</c>.
    </ol>


  <H3> Invert Synthetics: </H3>
    <p> Here we will determine what the synthetic and noised data show on the fault.</p>
    <ol type="i">
      <li> Edit new synthetic input file to either comment out or remove the sub-fault definitions.
        You can do this manually, or run a script:
        <div class = 'code-wrapper'> <pre>
        <c># in shell (command line)
        # this scrubs file directing it into a new file that then replaces the original.</c>
        grep -v subfault nicoya_ckbd_fwd_wNOISE.in > j1 ; mv j1 nicoya_ckbd_fwd_wNOISE.in </div></pre>

      <li> You can add or modify any other parameters that you want into the header of the file input file.
        We want to be sure that we're running a range of kappa values.
        Here it's 5 between 1000-5000, 5 between 7k and 15k, and 4 between 20k and 50k, but the useful range
        depends on the number of patches and relation to data.
<br>
        Modify <c>nicoya_ckbd_fwd_wNOISE.in</c> to include:
        <div class="code-wrapper"> <pre>
          surface free             # slip to the trench here
          kappa 2 1000 5000 5      # 1k-5k for with n=5
          kappa 2 7000 15000 5     # every 2k now
          kappa 2 20000 50000 4    # every 10k now
          resolution 1             # output the results of the resolution matrix (we can use later)
          lsqlin 10 1e-10          # less iterations and higher tolerance limits (faster runs with no real degradation).
          project on               # runs through and creates easy to read geographically projected outputs of model and slip parameters.</pre></div>
<br>
          Change the fault line to invert (e.g. make thrust range from -0.823 to 0, the ds0 and dsX values).
           <div class="code-wrapper"> <pre>
           <c>#fault is set for inversion (ds0, dxX = 0, -.0823)
           #fault type name    lon1         lat1       lon2         lat2         z1 z2      dip   ss  ds      ts ss0 ssX  ds0     dsX  ts0 tsX  Nd Ns</c>
           fault  2    nicoya  -85.54233907 8.74026277 -86.82826920 10.01077299  0  6.2e+04 17.0  0   -0.0823 0  0   0    -0.0823 0    0   0    30 40 </div></pre>

      <li>Run the inversion:
        <div class="code-wrapper"> <pre>
          <c>% within matlab</c>
          GTdef('nicoya_ckbd_fwd_wNOISE.in')</pre></div>

      <li> Now, evaluate/visualize the results of the inversion to determine which patches have better or worse representation
        of the original input model that you created (your checkerboards).
        A great way to do this is to create very similar plots of both the result of the forward prediction (nicoya_ckbd_fwd.out)
        and the new inverse at the kappa that you feel most appropriate (e.g. <c> nicoya_ckbd_fwd_wNOISE_k7000.out</c>).
        Now the files should be ready for the helper program <gr> GTdef_slipmodel.gmt</gr>.
        <div class="code-wrapper"> <pre>
          <c># in shell (command line)</c>
          GTdef_slipmodel.gmt -M nicoya_ckbd_fwd_lowNOISE.in -K 7000 -S100/100/10</pre></div>

        The figure should look like the example below.
         <center><img src="files/GTdef_slipmodel_nicoya_ckbd_fwd_lowNOISE_kp7000.png" width="700px"></center>
     <br>
<H3>Notes:</h3><ol type="i">
<li><p>As you can see in the above figure, the checkerboards are well represented right at the coast, however, the model becomes very
  smooth with apparent larger patches both updip and downdip.  The updip resolution problem comes from a lack of stations immediately overhead,
  however, the downdip problem is because our patches are too small, and the earth between the data and the fault is "smoothing it out".

  <p>To improve on the downdip problem, it is possible to make a hybrid checkerboard model with larger downdip patches
    (maybe 40x40 km), to test the resolution of larger slip features.
<li>Checkerboard testing is relatively straightforward, but a somewhat cumbersome problem with a visual and not very quantitative
  assessment of the model quality given data.  Instead, it may be much better to look at the <a href="#RES">output of the resolution matrix</a>, itself.
<li>The examples used in the checkerboard tests above use campaign data from the <a href = "https://nicoya.eas.gatech.edu/sites/nicoya/files/datasets/Protti_etal_2014_Campaign_results.txt">Nicoya Seismic Cycle Observatory GPS data.</a>
</br>
</section>


<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id="RES">
	<li> <h2> <a href = "#TOC">Resolution Spread Evaluation:</a></h2></li>
  <p>If you've ran inversions with the <c>'resolution'</c> flag set to one (see option in <a href="#cbt">Checkerboard Testing section</a>), we
  should have outputs with the tail <c>'_patches_R.out'</c> for each of the kappa values in our models. This file describes the output of
  the diagonals of the model resolution matrix, <c>R<sub>jj</sub></c>, as the product of the Generalized Inverse Matrix and the Green's function (see <a href="#THEORY">Theory</a> section).
  <p class="right"><c>(9)</c></p>
  <center><c><b>R</b> = <b> G<sup>-g</sup>G</b></c></center>
  Equation(7) from above can be rewritten as:
  <p class="right"><c>(10)</c></p>
  <center><c><b>G</b><sup>-g</sup> = [<b>G</b><sup>T</sup><b>W<sub>e</sub></b>G+ <i>&rho;</i><b>W<sub>m</sub></b>]<sup>-1</sup><b>G<sup>T</sup>W<sub>e</sub></b></c></center>
  where <b>W<sub>m</sub></b> is the Laplacian of the slip, <b>W<sub>e</sub></b> is the error weighting matrix, and <i>&rho;</i> is the roughness intensity applied to the models
  (Jonsson et al., 2002; Kyriakopoulos and Newman, 2016).</p>
<br>
<p>From the diagonals of the resolution matrix, <c><i>R<sub>jj</sub></i></c>,
  you can get a characterization of how spatially a model patch's resolution is spread output across the model space.
  This can be related in a single scalar per patch that is dependent on the patch size.
  This parameter is called the resolution spread, <c><i>r<sub>j</sub></i></c>, and is
  <p class="right"><c>(11)</c></p>
  <center><c><i>r<sub>j</sub></i> = <i>L<sub>j</sub></i> / &radic;<span style="text-decoration:overline"><i>R<sub>jj</sub></i></span></c>,</center>
  where <c><i>L<sub>j</sub></i></c> is the nominal patch size (Funning et al., 2005; Kyriakopoulos and Newman, 2016).
  <br>
  <p>Because <c><b>R</b></c> doesn't depend on the actual values of the data, but only its location and weighted errors, relative to the model,
    the same is true for <c><i>r<sub>j</sub></i></c>.</p>
<br>
<p>We've created a program that calculates <c><i>L<sub>j</sub></i></c>, and <c><i>r<sub>j</sub></i></c> for a selected component of slip.
 The program <gr>GTdef_Rmodel.gmt</gr> uses similar inputs to <gr>GTdef_slipmodel.gmt</gr>, but requires Kappa (-K) and Slip components (-C) to be described.
 As noted above, the program requires the respective <c>'_patches_R.out'</c> files that are created with the c>'resolution'</c> flag set to 1 before an inversion.

 <div class="code-wrapper"> <pre>
   <c># in shell (command line)</c>
   GTdef_Rmodel.gmt -M nicoya_ckbd_fwd_lowNOISE.in -K7000 -S D -D</pre></div>
This will plot the dip-slip (-S D) component, at &Kappa;=7000, displaying the result (-D). </p>
<br>

<p>The figure should look similar to the example below.
 <center><img src="files/GTdef_Rmodel_nicoya_ckbd_fwd_lowNOISE_kp7000_Rj.png" width="700px"></center>
</p>
<br>
<p> The real beauty of the Resolution Spread is in it's simplicity and quantitative nature.  Instead of creating apriori assessments
  of approximate resolvable model size, developing a model/running it, and doing "squinty-eyed" qualitative analysis of what you can
  resolve (as is done with Checkerboard testing), you get real numbers, with direct resolvable properties of patch size.</p>
<br>
<p> While plotting <c><i>r<sub>j</sub></i></c> gives a direct image of all patches average spread, you can use <c>resolution 2</c> to
  get information on the off-diagonal components of the model resolution matrix to plot the actual spatial smearing of individual
  patches, per component (see Kyriakopoulos and Newman, 2016).  You may need to develop your own plotting algoritm for this.


</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "gf">
	<li> <h2> <a href = "#TOC">Ingesting External Green's Functions</a></h2></li>
</section>

<hr size=2 color=darkgreen ><!---------------------------------------------------------------------------------------->

<section id= "ref">
<li> <h2> <a href = "#TOC"> References: </a> </h2></li>
<ul>
    <li><r>Needs to include other papers referred to above.  Inc. Menke, Wang et al (2003), Santamarina., Funning et al., 2005; Kyriakopoulos and Newman, 2016</r>
    <li><a href=http://geophysics.eas.gatech.edu/internal/papers/1985/Okada/Okada_BSSA_1985.pdf> Okada, Y. (1985). Surface deformation due to shear and tensile faults in a half-space, Bull. Seism. Soc. Am. 75, 1135-1154.</a>
    <li><a href=http://geophysics.eas.gatech.edu/people/anewman/research/papers/Chen_etal_GRL_2009.pdf> Chen, T., A. V. Newman, L, Feng, H. M. Fritz (2009), Slip Distribution from the 1 April 2007 Solomon Islands Earthquake: A Unique Image of Near-Trench Rupture, Geophys. Res. Lett., 36, L16307, doi:10.1029/2009GL039496. </a>
    <li><a href=http://geophysics.eas.gatech.edu/people/anewman/research/papers/Feng_etal_JGR_2012.pdf> Feng, L., A. V. Newman, J. M. Protti, V. González, Y. Jiang, T. H. Dixon (2012), Active Deformation near the Nicoya Peninsula, Northwestern Costa Rica, Between 1996 and 2010: Interseismic Megathrust Coupling, J. Geophys. Res., 117, B06407, doi:10.1029/2012JB009230. </a>
</ul>



<!--end sections-->
</ol>
</td> </tr>


<!--footer-->
<tr> <td>
<center>
<hr size=3 color=black ><!---------------------------------------------------------------------------------------->
   <font size=2 color=darkblue> <I>murekezi<IMG class="noborder" src=http://geophysics.eas.gatech.edu/anewman/pics/at_10.png>gatech.edu</I>, <I>anewman<IMG class="noborder" src=http://geophysics.eas.gatech.edu/anewman/pics/at_10.png>gatech.edu</I></font> | <font size=2 color=darkblue><I>Updated:
     <script language="Javascript">
     document.write(document.lastModified);
     </script>
   </I></font>
   </center>
</td> </tr>
</table>
</body>
</html>
