#!/bin/bash
# program to plot the trade-off between model and data misfit with model roughness.
# uses model_inv.out
# V1.0  AVN
# Thu Jun  4 14:16:45 EDT 2020

# check to make certain variable was cleared
  if   [ ${#} -lt "1" ] ; then
	  printf "Usage: %s 'model_inv.out' 
	     'model_inv.out' should be the output file that contains the fitting summary 
	        for range of generalization parameters (kappa).
		
	  Requires:  
	     Model files: (all files are in current directory)
	       model_inv.out: The model inversion summary file. 
	     Programs: 
	       gmt v5 or greater
	       open or xdg-open (standard on mac and most linux distributions, respectively)
	       a few standard gnu commands (awk, test, echo, basename; likely on your system already)
          Caveats: 
	     No labels exist internally.  Kappa values are labeled next to the green circles 
	       showing the roughness/RMS trade-off.  Red is the derivative of the data.
	\nExample: %s SI_2DCHK_C2_wNOISE_inv.out\n" $(basename "$0") $(basename "$0") ; exit 1
  fi

SUMMARY=$1

# check to see if the required files exist and are readable
test -r "$SUMMARY" || { echo "ERROR: Cannot find $SUMMARY. Exiting." ;  exit 1 ; }

# first things first 
# how big is this thing?
   SCALE=16
   # bounding boxes are 10% larger on either side
   #  # Xs  (2d roughness)
   #  XMIN=$(awk '$1!~"#" {print $13}' $SUMMARY | gmt info  -C | awk '{printf "%.1e", $1-0.1*($2-$1)}')
   #  XMAX=$(awk '$1!~"#" {print $13}' $SUMMARY | gmt info  -C | awk '{printf "%.1e", $2+0.1*($2-$1)}')
   #  # Ys  (rms)
   #  YMIN=$(awk '$1!~"#" {print $7}' $SUMMARY | gmt info  -C | awk '{printf "%.1e", $1-0.1*($2-$1)}')
   #  YMAX=$(awk '$1!~"#" {print $7}' $SUMMARY | gmt info  -C | awk '{printf "%.1e", $2+0.1*($2-$1)}')
   #  RANGE="-R$XMIN/$XMAX/$YMIN/$YMAX"


   DX="$(awk '$1!~"#"{print $13}' $SUMMARY | gmt info -I.001 -C | awk '{printf" %1.0e", ($2-$1)/10}')"
   DY="$(awk '$1!~"#"{print $7}'  $SUMMARY | gmt info -I.001 -C | awk '{printf" %1.0e", ($2-$1)/20}')"
   RANGE="$(awk '$1!~"#"{print $13,$7}' $SUMMARY | gmt info -I"$DX/$DY" )"
   #echo $DX $DY
   #echo $RANGE
   PROJ="-JX$SCALE"


  BGN="$RANGE $PROJ -K"
  MID="$RANGE $PROJ -O -K"
  END="$RANGE $PROJ -O"

  OUTFILE=$(basename $0 .gmt)_$(basename $SUMMARY .out).ps
#######################################
gmt set MAP_FRAME_TYPE plain  MAP_FRAME_PEN black

# put hidden stamp in file that will denote its source
  echo " %% created by ${USER} using ${HOST}:${PWD}/$0 $* " >>$OUTFILE
#######################################
gmt psbasemap  -X2  -Y10.5 $BGN -P -B"$DX":"Roughness [cm/km^2]":/"${DY}":"RMS Misfit [m]":"WeSn" >$OUTFILE


# plot station locations
#line
awk '$1!~"#" {print $13,$7}' $SUMMARY |  \
	gmt psxy  $MID   -W2 >>$OUTFILE
#green points
awk '$1!~"#" {print $13,$7}' $SUMMARY |  \
	gmt psxy  $MID  -Sc0.3 -G0/255/0 -W0.2 >>$OUTFILE
#text
awk '$1!~"#" {printf "%e %e %5.1e \n", $13+DX/5,$7+DY/5, $2}' DX="$DX" DY="$DY" $SUMMARY | \
	gmt pstext -F+a0+jLB+f12p,Helvetica,black $MID -N >>$OUTFILE

# plot 2nd-order derivatives
gmt set MAP_FRAME_TYPE plain  MAP_FRAME_PEN red
#2ndorder
#DRV=d2rmsdr2.txt
#sort -g -k13 $SUMMARY | awk 'NR==2{X=$13;Y=$7} NR>2{dydx=($7-Y)/($13-X); print X,dydx ;X=$13;Y=$7}' |\
#        awk 'NR==1{X=$1;Y=$2} NR>1{d2ydx2=($2-Y)/($1-X); print X,d2ydx2 ;X=$1;Y=$2}' > $DRV
#1st order
DRV=drmsdr.txt
sort -g -k13 $SUMMARY | awk 'NR==2{X=$13;Y=$7} NR>2{dydx=($7-Y)/100/($13-X); print X,dydx ;X=$13;Y=$7}' >$DRV
   DY2="$(awk '$1!~"#"{print $2}'  $DRV | gmt info -I.001 -C | awk '{printf "%.0e", ($2-$1)/10}')"
   YRANGE2="$(gmt info $DRV -I"$DX/$DY2" | awk -F"/" '{print $3"/"$4}' )"
   RANGE2="$(echo $RANGE | awk -F"/" '{print $1"/"$2"/"Y2}' Y2="$YRANGE2")"
gmt psbasemap -O -K $RANGE2 $PROJ -B"$DX/${DY2}":"dy/dx [km^2]":"E" >>$OUTFILE
gmt psxy $DRV  $RANGE2 $PROJ -O -K -N -W1,red >>$OUTFILE
gmt psxy $DRV  $RANGE2 $PROJ -O -N -Sc0.2 -Gred -W0.2 >>$OUTFILE


# create PNG output from PS file
  OUTPNG=$(basename $OUTFILE .ps).png
  # 600dpi 0.3cm margin on all sides and 50%scale
  gmt psconvert $OUTFILE -E600 -A1c+S0.5 -Tg -F$OUTPNG

if [ -x $( which open ) ] ; then 
     open $OUTPNG 
elif  [ -x $( which xdg-open ) ] ; then
     xdg-open $OUTPNG &> /dev/null &  
else
     echo "WARNING: cannot open $OUTPNG, no viewer available" 
fi	
#gv -scale=2  $OUTFILE & 
