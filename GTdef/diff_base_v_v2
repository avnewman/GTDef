ckm2LLd.m
ckm2LL.m
diff: v2/ckm2LL.m: No such file or directory
disloc3d_mod2.m
1,2c1,31
< function [U,D,S,FLAG,FLAG2] = disloc3d_mod2(M,Xin,mu,nu)
< %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
---
> function [U,D,E,S,FLAG,FLAG2] = disloc3d_mod2(M,Xin,mu,nu)
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                            disloc3d_mod2.m                              %
> % INPUT (row-wise):                                                       %
> % M   - regtangular planes                                                %
> % M   = [len;width;depth;dip;str;east;north;ss;ds;ts] [10*slip_num]       %
> % NMOD= slip_num                                                          %
> % Note: slip_num must be 1 here for the calculation of green functions    %
> % X   - point site locations in the local cartesian system                %
> % Xin = [ xx;yy;zz ] [3*station_num]                                      %
> % NSTAT = station_num                                                     %
> % mu  - shear modulus							  %
> % nu  - poisson's ratio                                                   %
> %                                                                         %
> % OUTPUT (column-wise):                                                   %
> % U   - displacement                                                      %
> % U   = [Ux;Uy;Uz] [3*station_num]                                        %
> % D   - displacement derivatives (not necessarily symmetric)              %
> % D   = [UXXT;UXYT;UXZT;UYXT;UYYT;UYZT;UZXT;UZYT;UZZT] [9*station_num]    %
> %       T means total here                                                %
> % E   - symmetric strain tensor (Voigt notation of 6-dimensional vector)  %
> % E   = [EXX;EYY;EZZ;EYZ;EXZ;EXY] [6*station_num]                         %
> % S   - symmetric stress tensor (Voigt notation of 6-dimensional vector)  %
> % S   = [SXX;SYY;SZZ;SYZ;SXZ;SXY] [6*station_num]                         %
> %                                                                         % 
> % functions used in this file: DC3D; DCCON0; DCCON2; UA; UB; UC           %
> % original Okada code                                                     %
> % corrected U(:,11) in UA function lfeng Fri Jun 15 13:30:24 SGT 2012     %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> 
> 
55c84
<     MU=mu;
---
>     MU=mu; 
74c103,104
<             
---
>                 % real strike = MODEL(5)
>                 % STRIKE here = start from east + clockwise positive
76,77c106,107
<     		CS = cos(STRIKE);
<     		SS = sin(STRIKE);
---
>                 CS = cos(STRIKE);
>                 SS = sin(STRIKE);
100a131
>                 % coordinate transformation
130,149c161,212
<         UOUT=[UXT UYT UZT];
<         DOUT=[UXXT UXYT UXZT UYXT UYYT UYZT UZXT UZYT UZZT];
<         THETA=DOUT(1)+DOUT(5)+DOUT(9);
<                            
<         SOUT(1)=LAMBDA*THETA+2*MU*DOUT(1);
<         SOUT(2)=MU*(DOUT(2)+DOUT(4));
<         SOUT(3)=MU*(DOUT(3)+DOUT(7));
<         SOUT(4)=LAMBDA*THETA+2*MU*DOUT(5);
<         SOUT(5)=MU*(DOUT(6)+DOUT(8));
<         SOUT(6)=LAMBDA*THETA+2*MU*DOUT(9);
<         
<         for J=1:3
<             U(J,I)=UOUT(J);
<         end
<         for J=1:9
<             D(J,I)=DOUT(J);
<         end
<         for J=1:6
<             S(J,I)=SOUT(J);
<         end
---
> 	    % UOUT - displacements
>             UOUT=[UXT UYT UZT];
> 	    % DOUT - displacement derivatives
> 	    % DOUT(1) = UXXT 
> 	    % DOUT(2) = UXYT 
> 	    % DOUT(3) = UXZT 
> 	    % DOUT(4) = UYXT 
> 	    % DOUT(5) = UYYT 
> 	    % DOUT(6) = UYZT 
> 	    % DOUT(7) = UZXT 
> 	    % DOUT(8) = UZYT 
> 	    % DOUT(9) = UZZT 
>             DOUT=[UXXT UXYT UXZT UYXT UYYT UYZT UZXT UZYT UZZT];
> 	    % displacement derivatives to strain
> 	    % use Voigt notation of a six-dimensional vector form
> 	    EOUT=zeros(6,1);
>             EOUT(1)=UXXT;
>             EOUT(2)=UYYT;
>             EOUT(3)=UZZT;
>             EOUT(4)=0.5*(UYZT+UZYT);
>             EOUT(5)=0.5*(UXZT+UZXT);
>             EOUT(6)=0.5*(UXYT+UYXT);
>                                
> 	    % strain to stress
> 	    % use Voigt notation of a six-dimensional vector form
>             % SOUT(1) = SXX
>             % SOUT(2) = SYY
>             % SOUT(3) = SZZ
>             % SOUT(4) = SYZ
>             % SOUT(5) = SXZ
>             % SOUT(6) = SXY
>             THETA=UXXT+UYYT+UZZT;
>             SOUT=zeros(6,1);
>             SOUT(1)=LAMBDA*THETA+2*MU*UXXT;
>             SOUT(2)=LAMBDA*THETA+2*MU*UYYT;
>             SOUT(3)=LAMBDA*THETA+2*MU*UZZT;
>             SOUT(4)=2*MU*EOUT(4);
>             SOUT(5)=2*MU*EOUT(5);
>             SOUT(6)=2*MU*EOUT(6);
>             
>             for J=1:3
>                 U(J,I)=UOUT(J);
>             end
>             for J=1:9
>                 D(J,I)=DOUT(J);
>             end
>             for J=1:6
>                 E(J,I)=EOUT(J);
>             end
>             for J=1:6
>                 S(J,I)=SOUT(J);
>             end
151,153c214,216
<         FLAG(I)=FLAGOUT;
<         
<         UXT=0; UYT=0; UZT=0;
---
>             FLAG(I)=FLAGOUT;
>             
>             UXT=0; UYT=0; UZT=0;
155,157c218,220
<         UXXT=0; UXYT=0; UXZT=0;
<         UYXT=0; UYYT=0; UYZT=0;
<         UZXT=0; UZYT=0; UZZT=0;
---
>             UXXT=0; UXYT=0; UXZT=0;
>             UYXT=0; UYYT=0; UYZT=0;
>             UZXT=0; UZYT=0; UZZT=0;
174c237
< %                                                                        
---
> % OKADA COORD: ORIGIN OF FAULT COORD IS RECTANGULAR CENTER
177,178c240,241
< %*****   X,Y,Z : COORDINATE OF OBSERVING POINT                           
< %*****   DEPTH : SOURCE DEPTH                                            
---
> %*****   X,Y,Z : COORDINATE OF OBSERVING POINT IN FAULT COORD
> %*****   DEPTH : RECTANGULAR SOURCE CENTRAL DEPTH                                            
180,181c243,244
< %*****   AL1,AL2   : FAULT LENGTH (-STRIKE,+STRIKE)                      
< %*****   AW1,AW2   : FAULT WIDTH  ( DOWNDIP, UPDIP)                      
---
> %*****   AL1,AL2   : FAULT LENGTH (-STRIKE,+STRIKE) usually AL1==AL2 both +
> %*****   AW1,AW2   : FAULT WIDTH  ( DOWNDIP, UPDIP) usually AW1==AW2 both +                     
185,188c248,251
< %*****   UX, UY, UZ  : DISPLACEMENT ( UNIT=(UNIT OF DISL)                
< %*****   UXX,UYX,UZX : X-DERIVATIVE ( UNIT=(UNIT OF DISL) /              
< %*****   UXY,UYY,UZY : Y-DERIVATIVE        (UNIT OF X,Y,Z,DEPTH,AL,AW) ) 
< %*****   UXZ,UYZ,UZZ : Z-DERIVATIVE                                     
---
> %*****   UX, UY, UZ  : DISPLACEMENT (UNIT=(UNIT OF DISL)                
> %*****   UXX,UYX,UZX : X-DERIVATIVE (UNIT=(UNIT OF DISL)/(UNIT OF X,Y,Z,DEPTH,AL,AW)
> %*****   UXY,UYY,UZY : Y-DERIVATIVE (UNIT=(UNIT OF DISL)/(UNIT OF X,Y,Z,DEPTH,AL,AW) 
> %*****   UXZ,UYZ,UZZ : Z-DERIVATIVE (UNIT=(UNIT OF DISL)/(UNIT OF X,Y,Z,DEPTH,AL,AW)                                    
461c524
<         U(11)=                    ALP2*EZ;
---
>         DU(11)=                    ALP2*EZ;
GTdef_addall.m
GTdef_add_diagonal.m
GTdef_ckbd_mask.m
20c20,22
< % last modified by lfeng Thu Apr 14 13:03:22 EDT 2011				%
---
> % used structure lfeng Thu Feb 23 14:27:39 SGT 2012				%
> % last modified by lfeng Thu Feb 23 14:44:03 SGT 2012				%
> % no test has been done after last modification					%
24,31c26,30
< [ coord,smooth,surf,beta,rigidity,poisson,... 
<   flt1_name,flt1_num,flt1, flt2_name,flt2_num,flt2,...
<   flt3_name,flt3_num,flt3, flt4_name,flt4_num,flt4,...
<   ~,~,~,~,~,...
<   subflt_name,subflt,dip_name,dip,...
<   pnt_name,pnt_num,pnt_loc,pnt_disp,pnt_err,pnt_wgt,... 
<   bsl_name,bsl_num,bsl_loc,bsl_disp,bsl_err,bsl_wgt,...
<   prf_name,prf_num,prf,grd_name,grd_num,grd ] = GTdef_open(model_name);
---
> [ coord,smooth,surf,beta,rigidity,poisson,...
>   earth,edgrn,layer,...
>   flt1,flt2,flt3,flt4,flt5,...
>   bndry,subflt,dip,...
>   pnt,bsl,prf,grd ] = GTdef_open(model_name);
54c53
<     error('Slip is not correctly specified!');
---
>     error('GTdef_ckbd_mask ERROR: Slip is not correctly specified!');
64c63
< Bmodel = reshape(subflt(:,colnum),Nd,Ns);
---
> Bmodel = reshape(subflt.flt(:,colnum),Nd,Ns);
84d82
< 
105c103
< subflt(:,colnum) = model;
---
> subflt.flt(:,colnum) = model;
112,116c110,113
< pnt_num = 0; bsl_num = 0; prf_num = 0;grd_num = 0; nod_name = 0;
< GTdef_output(fout_name,'none','none',0,rigidity,poisson,flt1_name,flt1_num,flt1,flt2_name,flt2_num,flt2,flt3_name,flt3_num,flt3,...
<       	 flt4_name,flt4_num,flt4,{},0,[],{},[],...
<     	 subflt_name,subflt,dip_name,dip,pnt_name,pnt_num,[],bsl_name,bsl_num,[],...
<        	 prf_name,prf_num,prf,grd_name,grd_num,grd,nod_name,[],[]);
---
> pnt.num = 0; bsl.num = 0; prf.num = 0; grd.num = 0;
> 
> GTdef_output(fout_name,coord,'none','none',0,rigidity,poisson,earth,edgrn,layer,...
>     	     flt1,flt2,flt3,flt4,flt5,bndry,subflt,dip,pnt,bsl,prf,grd,nod,mod_info);
GTdef_ckbd_subflt.m
GTdef_condense.m
GTdef_diffdips.m
47c47
<     rowzero = find(rows==0) 				% find layers not specified with number of rows yet
---
>     rowzero = find(rows==0); 				% find layers not specified with number of rows yet
49,50c49,50
<     rowsum = sum(rows)  
<     if rowsum ~= Nd, error('Dip is not specified correctly!'); end
---
>     rowsum = sum(rows);  
>     if rowsum ~= Nd, error('GTdef_diffdips ERROR: Dip is not specified correctly!'); end
GTdef_fault1.m
diff: v2/GTdef_fault1.m: No such file or directory
GTdef_fault1p_to_okada.m
10,11c10,11
< %      z1  - vertical burial depth (top of fault)                         %  
< %      z2  - vertical locking depth (bottom of fault)                     %
---
> %      z1  - vertical burial depth (top of fault) >=0                     %  
> %      z2  - vertical locking depth (bottom of fault) >=0                 %
20c20
< % (2) disloc3d_mod2 format output in M:                                   %
---
> % (2) disloc3d_mod2 format output in M  [10*slipnum]                      %
24a25,27
> %									  %
> % OUTPUT								  %
> % M = [ len width depth dip str east north ss ds ts ] [slipnum*10]	  %
74c77
<         error('Dip must be within [0 180]!');
---
>         error('GTdef_fault1p_to_okada ERROR: dip must be within [0 180]!');
77c80
<    error('Burial depth can not be greater than locking depth!');
---
>    error('GTdef_fault1p_to_okada ERROR: burial depth can not be greater than locking depth!');
GTdef_fault2.m
diff: v2/GTdef_fault2.m: No such file or directory
GTdef_fault2p_to_okada.m
10,11c10,11
< %      z1  - vertical burial depth (top of fault)                         %  
< %      z2  - vertical locking depth (bottom of fault)                     %
---
> %      z1  - vertical burial depth (top of fault) >=0                     %  
> %      z2  - vertical locking depth (bottom of fault) >=0                 %
18c18
< % (2) disloc3d_mod2 format output in M:                                   %
---
> % (2) disloc3d_mod2 format output in M  [10*slipnum]                      %
23a24,26
> % OUTPUT								  %
> % M = [ len width depth dip str east north ss ds ts ] [slipnum*10]	  %
> %                                                                         %
74c77
<         error('Dip must be within [0 180]!');
---
>         error('GTdef_fault2p_to_okada ERROR: dip must be within [0 180]!');
77c80
<    error('Burial depth can not be greater than locking depth!');
---
>    error('GTdef_fault2p_to_okada ERROR: burial depth can not be greater than locking depth!');
GTdef_fault3.m
diff: v2/GTdef_fault3.m: No such file or directory
GTdef_fault4.m
diff: v2/GTdef_fault4.m: No such file or directory
GTdef_fault5.m
65c65
< if size(flt)~=[1 13], error('need a 1*13 fault vector for GTdef_fault5'); end
---
> if size(flt)~=[1 13], error('GTdef_fault5 ERROR: need a 1*13 fault vector as input!'); end
126c126
<     error('Surface smoothing is wrong!!!');
---
>     error('GTdef_fault5 ERROR: Surface smoothing is wrong!!!');
136c136
<     error('Smoothing method is wrong!!!');
---
>     error('GTdef_fault5 ERROR: Smoothing method is wrong!!!');
GTdef_forward.m
2,4c2,3
<             = GTdef_forward(Xgrn,Bgrn,Ngrn,sm,sm_abs,lb,ub,xx,...
<             		    pnt_loc,pnt_obs,pnt_obs_err,pnt_wgt,...
< 	    		    bsl_loc,bsl_obs,bsl_obs_err,bsl_wgt,nod_loc,smooth)
---
>          = GTdef_forward(Xgrn,Bgrn,Ngrn,sm,sm_abs,lb,ub,xx,...
>             		 pnt,bsl,nod,smooth)
12c11,12
< % Each fault has three (strike, dip, and tensile) components, so          %
---
> %-------------------------------------------------------------------------%
> % fault1 & fault2 have three (strike, dip, and tensile) components, so    %
14,16c14,23
< %  xx   - final values for ss,ds,ts 	[slip_num*1]                      %
< %  lb  - lower bounds for ss,ds,ts 	[slip_num*1]                      %
< %  ub  - upper bounds for ss,ds,ts	[slip_num*1]			  %
---
> %      xx  - final values for ss,ds,ts 	[slip_num*1]                      %
> %      lb  - lower bounds for ss,ds,ts 	[slip_num*1]                      %
> %      ub  - upper bounds for ss,ds,ts	[slip_num*1]			  %
> %-------------------------------------------------------------------------%
> % fault3 & fault4 have two (rake and tensile) components, so              %
> % slip_num = flt_num*2                                                    %
> %      xx  - final values for rs,ts 	[slip_num*1]                      %
> %      lb  - lower bounds for rs,ts 	[slip_num*1]                      %
> %      ub  - upper bounds for rs,ts	[slip_num*1]			  %
> %-------------------------------------------------------------------------%
28,36c35,47
< % Point:    pnt_loc     - [lon lat z]			(nn*3)	  	  % 
< %	    pnt_obs     - [east;north;vert]		(3nn*1)		  %
< %   	    pnt_obs_err - [east;north;vert]		(3nn*1)    	  %
< %   	    pnt_wgt     - [weight]			(nn*1)      	  % 
< % Baseline: bsl_loc     - [lon1 lat1 z1 lon2 lat2 z2]	(nn*6)    	  %
< %   	    bsl_obs     - [east;north;vert;length]      (4nn*1)    	  %
< %   	    bsl_obs_err - [east;north;vert;length]      (4nn*1)    	  %
< %   	    bsl_wgt     - [weight]                      (nn*1)      	  %
< % Profile   nod_loc	- [lon lat z]			(nn*3)	  	  %
---
> % Point:    pnt.loc     - [lon lat z]			(nn*3)	  	  % 
> %	    pnt.obs     - [east;north;vert]		(3nn*1)		  %
> %   	    pnt.obs_err - [east;north;vert]		(3nn*1)    	  %
> %   	    pnt.wgt     - [weight]			(nn*1)      	  % 
> %    	    pnt.obs_wgt - [pnt.wgt;pnt.wgt;pnt.wgt]     (3nn*1)		  %
> % 	 		  [east;north;vertical]				  %
> % Baseline: bsl.loc     - [lon1 lat1 z1 lon2 lat2 z2]	(nn*6)    	  %
> %   	    bsl.obs     - [east;north;vert;length]      (4nn*1)    	  %
> %   	    bsl.obs_err - [east;north;vert;length]      (4nn*1)    	  %
> %   	    bsl.wgt     - [weight]                      (nn*1)      	  %
> %    	    bsl.obs_wgt - [bsl.wgt;bsl.wgt;bsl.wgt;bsl.wgt] 		  %
> %			  [east;north;vertical;length]  (4nn*1)		  %
> % Profile   nod.loc	- [lon lat z]			(nn*3)	  	  %
40,41c51,52
< %mod_info = [data_num slip_num ndf rss rms wrss wrms chi2 rchi2 	  %
< %            r_1d r_2d strain ]				  		  %
---
> % mod_info = [ data_num slip_num ndf rss rms wrss wrms chi2 rchi2 	  %
> %              r_1d r_2d strain ]				  	  %
69c80,81
< % last modified by Lujia Feng Wed Jul 21 17:03:27 EDT 2010		  %
---
> % used structure lfeng Wed Feb 22 13:37:09 SGT 2012			  %
> % last modified by Lujia Feng Wed Feb 22 13:46:32 SGT 2012		  %
92c104
<     pnt_out = [ pnt_loc pnt_mod pnt_mod_err pnt_wgt ];		% reuse pnt_loc and pnt_wgt
---
>     pnt_out = [ pnt.loc pnt_mod pnt_mod_err pnt.wgt ];		% reuse pnt.loc and pnt.wgt
94c106
<     data_ind = find(~isnan(pnt_obs));				% exclude nan data
---
>     data_ind = find(~isnan(pnt.obs));				% exclude nan data
96,98c108,109
<     pnt_dif2 = (Xmod(data_ind)-pnt_obs(data_ind)).^2; 		% squared residuals/differences
<     pnt_err2 = pnt_obs_err(data_ind).^2; 			% squared errors
<     pnt_wgt3 = [pnt_wgt;pnt_wgt;pnt_wgt]; 			% (3*n)*1 weight vector [east;north;vertical]
---
>     pnt_dif2 = (Xmod(data_ind)-pnt.obs(data_ind)).^2; 		% squared residuals/differences
>     pnt_err2 = pnt.obs_err(data_ind).^2; 			% squared errors
100c111
<     wrss = wrss+sum(pnt_wgt3(data_ind).*pnt_dif2./pnt_err2); 	% weighted rss 
---
>     wrss = wrss+sum(pnt.obs_wgt(data_ind).*pnt_dif2./pnt_err2); % weighted rss 
107c118
<     bsl_out = [ bsl_loc bsl_mod bsl_mod_err bsl_wgt ]; 		% reuse bsl_loc and bsl_wgt
---
>     bsl_out = [ bsl.loc bsl_mod bsl_mod_err bsl.wgt ]; 		% reuse bsl.loc and bsl.wgt
109c120
<     data_ind = find(~isnan(bsl_obs));
---
>     data_ind = find(~isnan(bsl.obs));
111,113c122,123
<     bsl_dif2 = (Bmod(data_ind)-bsl_obs(data_ind)).^2;		% squared residuals/differences
<     bsl_err2 = bsl_obs_err(data_ind).^2;			% squared errors
<     bsl_wgt4 = [bsl_wgt;bsl_wgt;bsl_wgt;bsl_wgt];		% (4*n)*1 weight vector [east;north;vertical;length]
---
>     bsl_dif2 = (Bmod(data_ind)-bsl.obs(data_ind)).^2;		% squared residuals/differences
>     bsl_err2 = bsl.obs_err(data_ind).^2;			% squared errors
115c125
<     wrss = wrss+sum(bsl_wgt4(data_ind).*bsl_dif2./bsl_err2);	% weighted rss
---
>     wrss = wrss+sum(bsl.obs_wgt(data_ind).*bsl_dif2./bsl_err2);	% weighted rss
123c133
<     nod_out = [ nod_loc nod_mod nod_mod_err nod_wgt ]; 		% reuse nod_loc
---
>     nod_out = [ nod.loc nod_mod nod_mod_err nod_wgt ]; 		% reuse nod.loc
GTdef_grid.m
GTdef_invert.m
1,2c1
< function [ xx ] = GTdef_invert(Xgrn,Bgrn,sm,Aeq,beq,lb,ub,x0,...
<             		   pnt_obs,pnt_coef,bsl_obs,bsl_coef,beta)
---
> function [ xx ] = GTdef_invert(Xgrn,Bgrn,sm,Aeq,beq,lb,ub,x0,pnt,bsl,beta)
26,29c25,28
< % Point:    pnt_obs  - [east;north;vert]	     (3nn*1)		  %
< %   	    pnt_coef - [east;north;vert]	     (3nn*1)    	  %
< % Baseline: bsl_obs  - [east;north;vert;length]      (4nn*1)    	  %
< %   	    bsl_coef - [east;north;vert;length]      (4nn*1)    	  %
---
> % Point:    pnt.obs  - [east;north;vert]	     (3nn*1)		  %
> %   	    pnt.coef - [east;north;vert]	     (3nn*1)    	  %
> % Baseline: bsl.obs  - [east;north;vert;length]      (4nn*1)    	  %
> %   	    bsl.coef - [east;north;vert;length]      (4nn*1)    	  %
37d35
< % last modified by Lujia Feng Mon May 11 16:40:22 EDT 2009		  %
38a37,38
> % used structure lfeng Wed Feb 22 19:36:43 SGT 2012			  %
> % last modified by Lujia Feng Wed Feb 22 19:40:25 SGT 2012		  %
44,47c44,47
<     eq_num = size(Xgrn,1);
<     for ii = 1:eq_num
<         Xgrn(ii,:) = Xgrn(ii,:).*pnt_coef(ii);
< 	pnt_obs(ii) = pnt_obs(ii).*pnt_coef(ii);
---
>     eqNum = size(Xgrn,1);
>     for ii = 1:eqNum
>         Xgrn(ii,:) = Xgrn(ii,:).*pnt.coef(ii);
> 	pnt.obs(ii) = pnt.obs(ii).*pnt.coef(ii);
49,50c49,50
<     ind = find(~isnan(pnt_obs));		% exclude nan values
<     C = [ C;Xgrn(ind,:) ]; d = [ d;pnt_obs(ind) ];
---
>     ind = find(~isnan(pnt.obs));		% exclude nan values
>     C = [ C;Xgrn(ind,:) ]; d = [ d;pnt.obs(ind) ];
53,56c53,56
<     eq_num = size(Bgrn,1);
<     for ii = 1:eq_num
<         Bgrn(ii,:) = Bgrn(ii,:).*bsl_coef(ii,1);
< 	bsl_obs(ii,1) = bsl_obs(ii,1).*bsl_coef(ii,1);
---
>     eqNum = size(Bgrn,1);
>     for ii = 1:eqNum
>         Bgrn(ii,:) = Bgrn(ii,:).*bsl.coef(ii,1);
> 	bsl.obs(ii,1) = bsl.obs(ii,1).*bsl.coef(ii,1);
58,59c58,59
<     ind = find(~isnan(bsl_obs));		% exclude nan values
<     C = [ C;Bgrn(ind,:) ]; d = [ d;bsl_obs(ind) ];
---
>     ind = find(~isnan(bsl.obs));		% exclude nan values
>     C = [ C;Bgrn(ind,:) ]; d = [ d;bsl.obs(ind) ];
GTdef.m
1c1
< function [] = GTdef(fin_name,wnum)
---
> function [] = GTdef(finName,wnum)
4,11c4,11
< %                              GTdef.m                                    	%
< % 	       Georgia Tech Matlab program for deformation	  	  	%
< %		 Lujia Feng; Andrew V. Newman; Ting Chen   		  	%
< %									  	%
< % INPUT:									%
< % fin_name - input file name                                            	%
< % wnum     - num of matlab parallel workers to be used				%
< %   0: do not use parallel computing						%
---
> %                              	  GTdef.m                                       %
> %              Georgia Tech Matlab program for deformation                      %
> %                Lujia Feng; Andrew V. Newman; Ting Chen                        %
> %                                                                               %
> % INPUT:                                                                        %
> % finName - input file name                                                     %
> % wnum    - num of matlab parallel workers to be used                           %
> %   0: do not use parallel computing                                            %
15,26c15,24
< %									  	%
< % v1:									  	%
< %  first created by Lujia Feng Mon Apr 20 14:15:52 EDT 2009		  	%
< %  last modified by Lujia Feng Tue May 19 01:14:49 EDT 2009		  	%
< % v1.1:									  	%
< %  added coordiante type flag 'coord' lfeng Thu Nov 5 17:12:59 EST 2009   	%
< % v1.2:									  	%
< % added first derivative modes lfeng Tue Dec  1 14:31:10 EST 2009	  	%
< % modified beta (added beta) and roughness for 1st derivatives 	  	  	%
< % added 'dip' flag for bended faults lfeng Mon Dec  7 01:04:06 EST 2009	  	%
< % added 'freesurface' flag lfeng Wed Dec  9 17:00:58 EST 2009		  	%
< % added fault type 5 lfeng Fri Dec 11 10:57:18 EST 2009			  	%
---
> %                                                                               %
> % v1:                                                                           %
> % first created by Lujia Feng Mon Apr 20 14:15:52 EDT 2009                      %
> % last modified by Lujia Feng Tue May 19 01:14:49 EDT 2009                      %
> % added coordiante type flag 'coord' lfeng Thu Nov 5 17:12:59 EST 2009          %
> % added first derivative modes lfeng Tue Dec  1 14:31:10 EST 2009               %
> % modified beta (added beta) and roughness for 1st derivatives                  %
> % added 'dip' flag for bended faults lfeng Mon Dec  7 01:04:06 EST 2009         %
> % added 'freesurface' flag lfeng Wed Dec  9 17:00:58 EST 2009                   %
> % added fault type 5 lfeng Fri Dec 11 10:57:18 EST 2009                         %
28c26
< % changed 'coord' to string flag lfeng Wed Feb 24 13:40:01 EST 2010		%
---
> % changed 'coord' to string flag lfeng Wed Feb 24 13:40:01 EST 2010             %
30,32c28,35
< % added matlabpool lfeng Wed Dec  1 12:12:00 EST 2010				%
< % edited the origin definition lfeng Thu Apr  7 18:45:35 EDT 2011		%
< % last modified lfeng Thu Apr  7 18:45:48 EDT 2011				%
---
> % added matlabpool lfeng Wed Dec  1 12:12:00 EST 2010                           %
> % edited the origin definition lfeng Thu Apr  7 18:45:35 EDT 2011               %
> % v2:                                                                           %
> % used strucutres for passing parameters lfeng Wed Feb 22 03:39:11 SGT 2012     %
> % added layered earth model lfeng Tue Feb 28 03:44:29 SGT 2012                  %
> % new definition used for fault1, fault2, fault3 & fault4 lfeng May 8 2012      %
> % added polyconic projection lfeng Thu Jun  7 12:23:26 SGT 2012                 %
> % last modified lfeng Wed Jun 13 18:09:47 SGT 2012                              %
37,39c40,42
<    if matlabpool('size')>0
<       matlabpool close
<    end
---
>     if matlabpool('size')>0
>        matlabpool close
>     end
41,43c44,46
<    if matlabpool('size')==0
<       matlabpool
<    end
---
>     if matlabpool('size')==0
>        matlabpool
>     end
45,47c48,50
<    if matlabpool('size')==0
<       matlabpool('open',int32(wnum));
<    end
---
>     if matlabpool('size')==0
>        matlabpool('open',int32(wnum));
>     end
49c52
<    error('Matlabpool input is wrong!!!');
---
>     error('GTdef ERROR: Matlabpool input is wrong!!!');
55,62c58,63
<  [ coord,smooth,surf,beta,rigidity,poisson,... 
<    flt1_name,flt1_num,flt1, flt2_name,flt2_num,flt2,...
<    flt3_name,flt3_num,flt3, flt4_name,flt4_num,flt4,...
<    ~,~,~,~,~,...
<    subflt_name,subflt,dip_name,dip,...
<    pnt_name,pnt_num,pnt_loc,pnt_disp,pnt_err,pnt_wgt,... 
<    bsl_name,bsl_num,bsl_loc,bsl_disp,bsl_err,bsl_wgt,...
<    prf_name,prf_num,prf,grd_name,grd_num,grd ] = GTdef_open(fin_name);
---
> [ coord,smooth,surf,beta,rigidity,poisson,...
>   earth,edgrn,layer,...
>   flt1,flt2,flt3,flt4,flt5,...
>   bndry,subflt,dip,...
>   pnt,bsl,prf,grd,...
>   sspnt,ssflt1,ssflt2 ] = GTdef_open(finName);
64a66,68
> %basename = strtok(finName,'.');	% noly works for names without "."
> cellname = regexp(finName,'\.in','split');
> basename = char(cellname(1));
68,85c72,110
< if strcmp(coord,'geo')
<    lonlist = []; latlist = [];
<    if flt1_num~=0
<        lonlist = [ lonlist;flt1(:,1) ]; latlist = [ latlist;flt1(:,2) ];
<    end
<    if flt2_num~=0
<        lonlist = [ lonlist;flt2(:,1) ]; latlist = [ latlist;flt2(:,2) ];
<    end
<    if flt3_num~=0
<        lonlist = [ lonlist;flt3(:,1) ]; latlist = [ latlist;flt3(:,2) ];
<    end
<    if flt4_num~=0
<        lonlist = [ lonlist;flt4(:,1) ]; latlist = [ latlist;flt4(:,2) ];
<    end
<    lon0 = 0.5*(min(lonlist)+max(lonlist));
<    lat0 = 0.5*(min(latlist)+max(latlist));
< elseif strcmp(coord,'local')~=1
<     error('Coordinate input is wrong!!!');
---
> if strcmp(coord,'geo') || strcmp(coord,'geo_polyconic')
>     lonlist = []; latlist = [];
>     if flt1.num~=0
>         lonlist = [ lonlist;flt1.flt(:,1) ]; latlist = [ latlist;flt1.flt(:,2) ];
>     end
>     if flt2.num~=0
>         lonlist = [ lonlist;flt2.flt(:,1) ]; latlist = [ latlist;flt2.flt(:,2) ];
>     end
>     if flt3.num~=0
>         lonlist = [ lonlist;flt3.flt(:,1) ]; latlist = [ latlist;flt3.flt(:,2) ];
>     end
>     if flt4.num~=0
>         lonlist = [ lonlist;flt4.flt(:,1) ]; latlist = [ latlist;flt4.flt(:,2) ];
>     end
>     lon0 = 0.5*(min(lonlist)+max(lonlist));
>     lat0 = 0.5*(min(latlist)+max(latlist));
> elseif strcmpi(coord,'local')~=1
>     error('GTdef ERROR: Coordinate input is wrong!!!');
> end
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% layered earth %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % if layered model is used, green function library is built up here
> edgrnfcts = [];
> if strcmp(earth,'layered')
> fprintf(1,'\n..... calculating point source library ......\t');
> tic
>     %---------- only need to create green functions once ----------
>     %fedgrnName = [ basename '_edgrn.inp' ];
>     %GTdef_write_edgrn_input(fedgrnName,edgrn,layer);
>     %folderName = 'edgrnfcts';
>     %% create green function folder if it does not exist
>     %if ~exist(folderName,'dir'), mkdir(folderName); end
>     %system(['echo ' fedgrnName ' | /Users/lfeng/matlab/edgrn2.0']);
>     %%system(['echo ' fedgrnName ' | ./edgrn2.0']);
>     %--------------------------------------------------------------
> 
>     % read in point source green functions
>     [ edgrn,edgrnfcts ] = GTdef_read_edgrn_output(edgrn);
> toc
88c113
< pnt_crt = []; pnt_obs = []; pnt_obs_err = []; pnt_obs_wgt = []; pnt_coef = [];
---
> pnt.crt = []; pnt.obs = []; pnt.obs_err = []; pnt.obs_wgt = []; pnt.coef = [];
90c115,116
< fprintf(1,'\n......... processing the point data .........\t');
---
> if pnt.num~=0
> fprintf(1,'\n........... processing point data ...........\t');
92d117
< if pnt_num~=0
95c120,123
<        [pxx,pyy] = LL2ckmd(pnt_loc(:,1),pnt_loc(:,2),lon0,lat0,0);
---
>        [pxx,pyy] = LL2ckmd(pnt.loc(:,1),pnt.loc(:,2),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [pxx,pyy] = latlon_to_xy(pnt.loc(:,1),pnt.loc(:,2),lon0,lat0);
98c126
<        pxx = pnt_loc(:,1); pyy = pnt_loc(:,2);
---
>        pxx = pnt.loc(:,1); pyy = pnt.loc(:,2);
100,101c128,130
<     pzz = zeros(1,length(pxx));
<     pnt_crt = [pxx'; pyy'; pzz];                   	% cartesian - 3*n matrix [xx;yy;zz]; it is just Xin
---
>     pzz = pnt.loc(:,3);
>     zz_ind = pzz>0; pzz(zz_ind) = 0;                % positive depths are all set to be zero   
>     pnt.crt = [pxx'; pyy'; pzz'];                   % cartesian - 3*n matrix [xx;yy;zz]; it is just Xin
103,107c132,135
<     pnt_obs = reshape(pnt_disp,[],1);			% (3*n)*1 observation vector [east;north;vertical]
<     pnt_obs_err = reshape(pnt_err,[],1);		% (3*n)*1 error vector [east;north;vertical]
<     pnt_obs_wgt = [pnt_wgt;pnt_wgt;pnt_wgt]; 		% (3*n)*1 weight vector [east;north;vertical]
<     pnt_coef = sqrt(pnt_obs_wgt)./pnt_obs_err;
< end
---
>     pnt.obs = reshape(pnt.disp,[],1);			    % (3*n)*1 observation vector [east;north;vertical]
>     pnt.obs_err = reshape(pnt.err,[],1);		    % (3*n)*1 error vector [east;north;vertical]
>     pnt.obs_wgt = [pnt.wgt;pnt.wgt;pnt.wgt]; 		% (3*n)*1 weight vector [east;north;vertical]
>     pnt.coef = sqrt(pnt.obs_wgt)./pnt.obs_err;
108a137
> end
110c139
< bsl_crt = []; bsl_obs = []; bsl_obs_err = []; bsl_obs_wgt = []; bsl_coef = [];
---
> bsl.crt = []; bsl.obs = []; bsl.obs_err = []; bsl.obs_wgt = []; bsl.coef = [];
112c141,142
< fprintf(1,'\n........ processing the baseline data .......\t');
---
> if bsl.num~=0
> fprintf(1,'\n.......... processing baseline data .........\t');
114d143
< if bsl_num~=0
117,118c146,151
<        [bx1,by1] = LL2ckmd(bsl_loc(:,1),bsl_loc(:,2),lon0,lat0,0);
<        [bx2,by2] = LL2ckmd(bsl_loc(:,4),bsl_loc(:,5),lon0,lat0,0);
---
>        [bx1,by1] = LL2ckmd(bsl.loc(:,1),bsl.loc(:,2),lon0,lat0,0);
>        [bx2,by2] = LL2ckmd(bsl.loc(:,4),bsl.loc(:,5),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [bx1,by1] = latlon_to_xy(bsl.loc(:,1),bsl.loc(:,2),lon0,lat0);
>        [bx2,by2] = latlon_to_xy(bsl.loc(:,4),bsl.loc(:,5),lon0,lat0);
121,122c154,155
<        bx1 = bsl_loc(:,1); by1  = bsl_loc(:,2);
<        bx2 = bsl_loc(:,4); by2  = bsl_loc(:,5);
---
>        bx1 = bsl.loc(:,1); by1  = bsl.loc(:,2);
>        bx2 = bsl.loc(:,4); by2  = bsl.loc(:,5);
124,125c157,158
<     bz1 = bsl_loc(:,3);	 bz2 = bsl_loc(:,6);
<     bsl_crt = [bx1'; by1'; bz1';bx2'; by2'; bz2'];      % cartesian - 6*n matrix [bx1;by1;bz1;bx2;by2;bz2]; it is just Bin
---
>     bz1 = bsl.loc(:,3);	 bz2 = bsl.loc(:,6);
>     bsl.crt = [bx1'; by1'; bz1';bx2'; by2'; bz2'];      % cartesian - 6*n matrix [bx1;by1;bz1;bx2;by2;bz2]; it is just Bin
127,131c160,163
<     bsl_obs = reshape(bsl_disp,[],1);			% (4*n)*1 observation vector [east;north;vertical:length]
<     bsl_obs_err = reshape(bsl_err,[],1);		% (4*n)*1 error vector [east;north;vertical:length]
<     bsl_obs_wgt = [bsl_wgt;bsl_wgt;bsl_wgt;bsl_wgt];	% (4*n)*1 weight vector [east;north;vertical:length]
<     bsl_coef = sqrt(bsl_obs_wgt)./bsl_obs_err;
< end
---
>     bsl.obs = reshape(bsl.disp,[],1);                   % (4*n)*1 observation vector [east;north;vertical:length]
>     bsl.obs_err = reshape(bsl.err,[],1);                % (4*n)*1 error vector [east;north;vertical:length]
>     bsl.obs_wgt = [bsl.wgt;bsl.wgt;bsl.wgt;bsl.wgt];	% (4*n)*1 weight vector [east;north;vertical:length]
>     bsl.coef = sqrt(bsl.obs_wgt)./bsl.obs_err;
132a165
> end
134,135c167
< 
< nod_loc = []; nod_crt = []; nod_lon = []; nod_lat = []; nod_name = {};
---
> nod.loc = []; nod.crt = []; nod.lon = []; nod.lat = []; nod.name = {};
137c169,170
< fprintf(1,'\n..... processing the profile & grid data ....\t');
---
> if prf.num~=0||grd.num~=0
> fprintf(1,'\n....... processing profile & grid data ......\t');
139,144c172,178
< if prf_num~=0
<     for ii = 1:prf_num
<         plon = []; plat = []; pname = {};
< 	[ plon,plat,pname ] = GTdef_profile(prf(ii,:),prf_name{ii});
< 	nod_lon = [ nod_lon plon ]; nod_lat = [ nod_lat plat ];
<     	nod_name = [ nod_name; pname ];   
---
>     if prf.num~=0
>         for ii = 1:prf.num
>             plon = []; plat = []; pname = {};
>     	[ plon,plat,pname ] = GTdef_profile(prf.prf(ii,:),prf.name{ii});
>     	nod.lon = [ nod.lon plon ]; nod.lat = [ nod.lat plat ];
>         	nod.name = [ nod.name; pname ];   
>         end
146,152c180,186
< end
< if grd_num~=0
<     for ii = 1:grd_num
<         glon = []; glat = []; gname = {};
< 	[ glon,glat,gname ] = GTdef_grid(grd(ii,:),grd_name{ii});
< 	nod_lon = [ nod_lon glon ]; nod_lat = [ nod_lat glat ];
<     	nod_name = [ nod_name; gname ];   
---
>     if grd.num~=0
>         for ii = 1:grd.num
>             glon = []; glat = []; gname = {};
>     	[ glon,glat,gname ] = GTdef_grid(grd.grd(ii,:),grd.name{ii});
>     	nod.lon = [ nod.lon glon ]; nod.lat = [ nod.lat glat ];
>         	nod.name = [ nod.name; gname ];   
>         end
154,157c188,189
< end
< if prf_num~=0||grd_num~=0
<     nod_zz = nan(length(nod_lon),1);
<     nod_loc = [ nod_lon' nod_lat' nod_zz ];
---
>     nod_zz = nan(length(nod.lon),1);
>     nod.loc = [ nod.lon' nod.lat' nod_zz ];
159c191,194
<        [nod_xx,nod_yy] = LL2ckmd(nod_lon,nod_lat,lon0,lat0,0);
---
>        [nod_xx,nod_yy] = LL2ckmd(nod.lon,nod.lat,lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [nod_xx,nod_yy] = latlon_to_xy(nod.lon,nod.lat,lon0,lat0);
162c197
<        nod_xx = nod_lon; nod_yy = nod_lat;
---
>        nod_xx = nod.lon; nod_yy = nod.lat;
165c200,221
<     nod_crt = [ nod_xx;nod_yy;nod_zz ];			% cartesian - 3*n matrix [xx;yy;zz]; it is just Nin
---
>     nod.crt = [ nod_xx;nod_yy;nod_zz ];			% cartesian - 3*n matrix [xx;yy;zz]; it is just Nin
> toc
> end
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% stress point data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> if sspnt.num~=0
> fprintf(1,'\n....... processing stress point data ........\t');
> tic
>     % convert point data from geographic to local cartesian coordinate
>     if strcmp(coord,'geo')
>        [sspxx,sspyy] = LL2ckmd(sspnt.loc(:,1),sspnt.loc(:,2),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [sspxx,sspyy] = latlon_to_xy(sspnt.loc(:,1),sspnt.loc(:,2),lon0,lat0);
>     end
>     if strcmp(coord,'local')
>        sspxx = sspnt.loc(:,1); sspyy = sspnt.loc(:,2);
>     end
>     sspzz = sspnt.loc(:,3);
>     zz_ind = sspzz>0;  sspzz(zz_ind) = 0;               % positive depths are all set to be zero
>     sspnt.crt = [sspxx'; sspyy'; sspzz'];               % cartesian - 3*n matrix; it is just Xin
> toc
166a223,249
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% stress fault1 data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> if ssflt1.fltnum~=0
> fprintf(1,'\n....... processing stress fault type-1 ......\t');
> tic
>     if strcmp(coord,'geo')
>        [x1,y1] = LL2ckmd(ssflt1.flt(:,1),ssflt1.flt(:,2),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [x1,y1] = latlon_to_xy(ssflt1.flt(:,1),ssflt1.flt(:,2),lon0,lat0);
>     end
>     if strcmp(coord,'local')
>        x1 = ssflt1.flt(:,1); y1 = ssflt1.flt(:,2);
>     end
>     ssflt1.flt = [x1 y1 ssflt1.flt(:,3:end)];
>     [ ssflt1 ] = GTdef_stressfault1(ssflt1,dip);
>     if strcmp(coord,'geo')
>        [lon1,lat1] = ckm2LLd(ssflt1.crt(1,:),ssflt1.crt(2,:),lon0,lat0,0);
>        ssflt1.loc = [ lon1; lat1; ssflt1.crt(3,:) ]';
>     end
>     if strcmp(coord,'geo_polyconic')
>        [lon1,lat1] = xy_to_latlon(ssflt1.crt(1,:),ssflt1.crt(2,:),lon0,lat0);
>        ssflt1.loc = [ lon1; lat1; ssflt1.crt(3,:) ]';
>     end
>     if strcmp(coord,'local')
>        ssflt1.loc = ssflt1.crt';
>     end
167a251
> end
168a253,283
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% stress fault2 data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> if ssflt2.fltnum~=0
> fprintf(1,'\n....... processing stress fault type-2 ......\t');
> tic
>     if strcmp(coord,'geo')
>        [x2_1,y2_1] = LL2ckmd(ssflt2.flt(:,1),ssflt2.flt(:,2),lon0,lat0,0);
>        [x2_2,y2_2] = LL2ckmd(ssflt2.flt(:,3),ssflt2.flt(:,4),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [x2_1,y2_1] = latlon_to_xy(ssflt2.flt(:,1),flt2.flt(:,2),lon0,lat0);
>        [x2_2,y2_2] = latlon_to_xy(ssflt2.flt(:,3),flt2.flt(:,4),lon0,lat0);
>     end
>     if strcmp(coord,'local')
>        x2_1 = ssflt2.flt(:,1); y2_1 = ssflt2.flt(:,2);
>        x2_2 = ssflt2.flt(:,3); y2_2 = ssflt2.flt(:,4);
>     end
>     ssflt2.flt = [x2_1 y2_1 x2_2 y2_2 ssflt2.flt(:,5:end)];
>     [ ssflt2 ] = GTdef_stressfault2(ssflt2,dip);
>     if strcmp(coord,'geo')
>        [lon2,lat2] = ckm2LLd(ssflt2.crt(1,:),ssflt2.crt(2,:),lon0,lat0,0);
>        ssflt2.loc = [ lon2; lat2; ssflt2.crt(3,:) ]';
>     end
>     if strcmp(coord,'geo_polyconic')
>        [lon2,lat2] = xy_to_latlon(ssflt2.crt(1,:),ssflt2.crt(2,:),lon0,lat0);
>        ssflt2.loc = [ lon2; lat2; ssflt2.crt(3,:) ]';
>     end
>     if strcmp(coord,'local')
>        ssflt2.loc = ssflt2.crt';
>     end
> toc
> end
173a289,290
> % stress calculation
> Min0 = [];
175c292
< if flt1_num~=0
---
> if flt1.num~=0
179c296,299
<        [x1,y1] = LL2ckmd(flt1(:,1),flt1(:,2),lon0,lat0,0);
---
>        [x1,y1] = LL2ckmd(flt1.flt(:,1),flt1.flt(:,2),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [x1,y1] = latlon_to_xy(flt1.flt(:,1),flt1.flt(:,2),lon0,lat0);
182c302,316
<        x1 = flt1(:,1); y1 = flt1(:,2);
---
>        x1 = flt1.flt(:,1); y1 = flt1.flt(:,2);
>     end
>     for ii = 1:flt1.num
>         cflt_name = flt1.name{ii};
>     	% find subfaults for the master fault
>     	sub_ind = strcmpi(cflt_name,subflt.name);
>         % find dips for the master fault
>     	dip_ind = strcmpi(cflt_name,dip.name);
>         [ Xgrn1,Bgrn1,Ngrn1,sm1,sm1_abs,Aeq1,beq1,lb1,ub1,x01,Min01 ] = ...
>           GTdef_fault1dif([x1(ii) y1(ii) flt1.flt(ii,3:end)],...
> 	                 subflt.flt(sub_ind,:),dip.dip(dip_ind,:),pnt.crt,bsl.crt,nod.crt,...
> 	                 earth,rigidity,poisson,edgrn,edgrnfcts,smooth,surf);
>     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
> 	                                                Xgrn1,Bgrn1,Ngrn1,sm1,sm1_abs,Aeq1,beq1,lb1,ub1,x01);
>         Min0 = [ Min0; Min01 ];
184,186d317
<     [ Xgrn1,Bgrn1,Ngrn1,sm1,Aeq1,beq1,lb1,ub1,x01 ] = GTdef_fault1([x1 y1 flt1(:,3:end)],pnt_crt,bsl_crt,nod_crt,rigidity,poisson);
<     [ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,[],Aeq,beq,lb,ub,x0,...
<                                                           Xgrn1,Bgrn1,Ngrn1,sm1,[],Aeq1,beq1,lb1,ub1,x01);
191c322
< if flt2_num~=0
---
> if flt2.num~=0
195,196c326,327
<        [x2_1,y2_1] = LL2ckmd(flt2(:,1),flt2(:,2),lon0,lat0,0);
<        [x2_2,y2_2] = LL2ckmd(flt2(:,3),flt2(:,4),lon0,lat0,0);
---
>        [x2_1,y2_1] = LL2ckmd(flt2.flt(:,1),flt2.flt(:,2),lon0,lat0,0);
>        [x2_2,y2_2] = LL2ckmd(flt2.flt(:,3),flt2.flt(:,4),lon0,lat0,0);
198,200c329,349
<     if  strcmp(coord,'local')
<        x2_1 = flt2(:,1); y2_1 = flt2(:,2);
<        x2_2 = flt2(:,3); y2_2 = flt2(:,4);
---
>     if strcmp(coord,'geo_polyconic')
>        [x2_1,y2_1] = latlon_to_xy(flt2.flt(:,1),flt2.flt(:,2),lon0,lat0);
>        [x2_2,y2_2] = latlon_to_xy(flt2.flt(:,3),flt2.flt(:,4),lon0,lat0);
>     end
>     if strcmp(coord,'local')
>        x2_1 = flt2.flt(:,1); y2_1 = flt2.flt(:,2);
>        x2_2 = flt2.flt(:,3); y2_2 = flt2.flt(:,4);
>     end
>     for ii = 1:flt2.num
>         cflt_name = flt2.name{ii};
>     	% find subfaults for the master fault
>     	sub_ind = strcmpi(cflt_name,subflt.name);
> 	% find dips for the master fault
>     	dip_ind = strcmpi(cflt_name,dip.name);
>         [ Xgrn2,Bgrn2,Ngrn2,sm2,sm2_abs,Aeq2,beq2,lb2,ub2,x02,Min02 ] = ...
> 	GTdef_fault2dif([x2_1(ii) y2_1(ii) x2_2(ii) y2_2(ii) flt2.flt(ii,5:end)],...
> 	                subflt.flt(sub_ind,:),dip.dip(dip_ind,:),pnt.crt,bsl.crt,nod.crt,...
> 		        earth,rigidity,poisson,edgrn,edgrnfcts,smooth,surf);
>     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
> 	                                                Xgrn2,Bgrn2,Ngrn2,sm2,sm2_abs,Aeq2,beq2,lb2,ub2,x02);
>         Min0 = [ Min0; Min02 ];
202,204d350
<     [ Xgrn2,Bgrn2,Ngrn2,sm2,Aeq2,beq2,lb2,ub2,x02 ] = GTdef_fault2([x2_1 y2_1 x2_2 y2_2 flt2(:,5:end)],pnt_crt,bsl_crt,nod_crt,rigidity,poisson);
<     [ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,[],Aeq,beq,lb,ub,x0,...
<                                                           Xgrn2,Bgrn2,Ngrn2,sm2,[],Aeq2,beq2,lb2,ub2,x02);
209c355
< if flt3_num~=0
---
> if flt3.num~=0
213c359,362
<        [x3,y3] = LL2ckmd(flt3(:,1),flt3(:,2),lon0,lat0,0);
---
>        [x3,y3] = LL2ckmd(flt3.flt(:,1),flt3.flt(:,2),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo_polyconic')
>        [x3,y3] = latlon_to_xy(flt3.flt(:,1),flt3.flt(:,2),lon0,lat0);
216c365
<        x3 = flt3(:,1); y3 = flt3(:,2);
---
>        x3 = flt3.flt(:,1); y3 = flt3.flt(:,2);
218,219c367,368
<     for ii = 1:flt3_num
<         cflt_name = flt3_name{ii};
---
>     for ii = 1:flt3.num
>         cflt_name = flt3.name{ii};
221c370
<     	sub_ind = strcmpi(cflt_name,subflt_name);
---
>     	sub_ind = strcmpi(cflt_name,subflt.name);
223,229c372,379
<     	dip_ind = strcmpi(cflt_name,dip_name);
< 	Xgrn3 = []; Bgrn3 = []; Ngrn3 = []; Aeq3 = []; beq3 = []; lb3 = []; ub3 = []; x03 = [];		% reset empty
<         [ Xgrn3,Bgrn3,Ngrn3,sm3,sm3_abs,Aeq3,beq3,lb3,ub3,x03 ] = ...
< 	GTdef_fault3([x3(ii) y3(ii) flt3(ii,3:end)],subflt(sub_ind,:),dip(dip_ind,:),pnt_crt,bsl_crt,nod_crt,rigidity,poisson,smooth,surf);
<     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = ...
< 	GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
< 	             Xgrn3,Bgrn3,Ngrn3,sm3,sm3_abs,Aeq3,beq3,lb3,ub3,x03);
---
>     	dip_ind = strcmpi(cflt_name,dip.name);
>         [ Xgrn3,Bgrn3,Ngrn3,sm3,sm3_abs,Aeq3,beq3,lb3,ub3,x03,Min03 ] = ...
> 	GTdef_fault3dif([x3(ii) y3(ii) flt3.flt(ii,3:end)],...
> 	                subflt.flt(sub_ind,:),dip.dip(dip_ind,:),pnt.crt,bsl.crt,nod.crt,...
> 	                earth,rigidity,poisson,edgrn,edgrnfcts,smooth,surf);
>     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
> 	                                                Xgrn3,Bgrn3,Ngrn3,sm3,sm3_abs,Aeq3,beq3,lb3,ub3,x03);
>         Min0 = [ Min0; Min03 ];
235c385
< if flt4_num~=0
---
> if flt4.num~=0
239,240c389,394
<        [x4_1,y4_1] = LL2ckmd(flt4(:,1),flt4(:,2),lon0,lat0,0);
<        [x4_2,y4_2] = LL2ckmd(flt4(:,3),flt4(:,4),lon0,lat0,0);
---
>        [x4_1,y4_1] = LL2ckmd(flt4.flt(:,1),flt4.flt(:,2),lon0,lat0,0);
>        [x4_2,y4_2] = LL2ckmd(flt4.flt(:,3),flt4.flt(:,4),lon0,lat0,0);
>     end
>     if strcmp(coord,'geo')
>        [x4_1,y4_1] = latlon_to_xy(flt4.flt(:,1),flt4.flt(:,2),lon0,lat0);
>        [x4_2,y4_2] = latlon_to_xy(flt4.flt(:,3),flt4.flt(:,4),lon0,lat0);
243,244c397,398
<        x4_1 = flt4(:,1); y4_1 = flt4(:,2);
<        x4_2 = flt4(:,3); y4_2 = flt4(:,4);
---
>        x4_1 = flt4.flt(:,1); y4_1 = flt4.flt(:,2);
>        x4_2 = flt4.flt(:,3); y4_2 = flt4.flt(:,4);
246,247c400,401
<     for ii = 1:flt4_num
<         cflt_name = flt4_name{ii};
---
>     for ii = 1:flt4.num
>         cflt_name = flt4.name{ii};
249c403
<     	sub_ind = strcmpi(cflt_name,subflt_name);
---
>     	sub_ind = strcmpi(cflt_name,subflt.name);
251,257c405,412
<     	dip_ind = strcmpi(cflt_name,dip_name);
< 	Xgrn4 = []; Bgrn4 = []; Ngrn4 = []; Aeq4 = []; beq4 = []; lb4 = []; ub4 = []; x04 = [];		% reset empty
<         [ Xgrn4,Bgrn4,Ngrn4,sm4,sm4_abs,Aeq4,beq4,lb4,ub4,x04 ] = ...
< 	GTdef_fault4([x4_1(ii) y4_1(ii) x4_2(ii) y4_2(ii) flt4(ii,5:end)],subflt(sub_ind,:),dip(dip_ind,:),pnt_crt,bsl_crt,nod_crt,rigidity,poisson,smooth,surf);
<     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = ...
< 	GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
< 	             Xgrn4,Bgrn4,Ngrn4,sm4,sm4_abs,Aeq4,beq4,lb4,ub4,x04);
---
>     	dip_ind = strcmpi(cflt_name,dip.name);
>         [ Xgrn4,Bgrn4,Ngrn4,sm4,sm4_abs,Aeq4,beq4,lb4,ub4,x04,Min04 ] = ...
> 	GTdef_fault4dif([x4_1(ii) y4_1(ii) x4_2(ii) y4_2(ii) flt4.flt(ii,5:end)],...
> 	                subflt.flt(sub_ind,:),dip.dip(dip_ind,:),pnt.crt,bsl.crt,nod.crt,...
> 		        earth,rigidity,poisson,edgrn,edgrnfcts,smooth,surf);
>     	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
> 	                                                Xgrn4,Bgrn4,Ngrn4,sm4,sm4_abs,Aeq4,beq4,lb4,ub4,x04);
>         Min0 = [ Min0; Min04 ];
260a416
> Min0
263,266c419,421
< flt5_num = 0;
< if flt5_num~=0
<     fprintf(1,'\n.......... processing fault type-5 ..........\t');
<     tic
---
> if flt5.num~=0
> fprintf(1,'\n.......... processing fault type-5 ..........\t');
> tic
268,272c423,434
<            [bx1,by1] = LL2ckmd(bndry(:,3),bndry(:,4),lon0,lat0,0);		% upleft point
<            [bx2,by2] = LL2ckmd(bndry(:,6),bndry(:,7),lon0,lat0,0);		% lower left point
<            [bx3,by3] = LL2ckmd(bndry(:,9),bndry(:,10),lon0,lat0,0);		% lower right point
<            [bx4,by4] = LL2ckmd(bndry(:,12),bndry(:,13),lon0,lat0,0);	% upleft point
<            bndry_crt = [ bx1 by1 bndry(:,5) bx2 by2 bndry(:,8) bx3 by3 bndry(:,11) bx4 by4 bndry(:,14) ];
---
>            [bx1,by1] = LL2ckmd(bndry.bd(:,3), bndry.bd(:,4), lon0,lat0,0);	% upleft point
>            [bx2,by2] = LL2ckmd(bndry.bd(:,6), bndry.bd(:,7), lon0,lat0,0);	% lower left point
>            [bx3,by3] = LL2ckmd(bndry.bd(:,9), bndry.bd(:,10),lon0,lat0,0);	% lower right point
>            [bx4,by4] = LL2ckmd(bndry.bd(:,12),bndry.bd(:,13),lon0,lat0,0);	% upleft point
>            bndry.crt = [ bx1 by1 bndry.bd(:,5) bx2 by2 bndry.bd(:,8) bx3 by3 bndry.bd(:,11) bx4 by4 bndry.bd(:,14) ];
>         end
>         if strcmp(coord,'geo_polyconic')
>            [bx1,by1] = latlon_to_xy(bndry.bd(:,3), bndry.bd(:,4), lon0,lat0);	% upleft point
>            [bx2,by2] = latlon_to_xy(bndry.bd(:,6), bndry.bd(:,7), lon0,lat0);	% lower left point
>            [bx3,by3] = latlon_to_xy(bndry.bd(:,9), bndry.bd(:,10),lon0,lat0);	% lower right point
>            [bx4,by4] = latlon_to_xy(bndry.bd(:,12),bndry.bd(:,13),lon0,lat0);	% upleft point
>            bndry.crt = [ bx1 by1 bndry.bd(:,5) bx2 by2 bndry.bd(:,8) bx3 by3 bndry.bd(:,11) bx4 by4 bndry.bd(:,14) ];
275c437
<     	bndry_crt = bndry;
---
>     	   bndry.crt = bndry.bd;
277,288c439,449
<         for ii = 1:flt5_num
<            cflt_name = flt5_name{ii};
<         	% find subfaults for the master fault
<         	sub_ind = strcmpi(cflt_name,subflt_name);
<         	% find the boundary for fault 5
<         	bnd_ind = strcmpi(cflt_name,bndry_name);
<     	Xgrn5 = []; Bgrn5 = []; Ngrn5 = []; Aeq5 = []; beq5 = []; lb5 = []; ub5 = []; x05 = [];		% reset empty
<             [ Xgrn5,Bgrn5,Ngrn5,sm5,sm5_abs,Aeq5,beq5,lb5,ub5,x05 ] = ...;
<     	GTdef_fault5(flt5,subflt(sub_ind,:),bndry(bnd_ind,:),pnt_crt,bsl_crt,nod_crt,rigidity,poisson,smooth,surf);
<         	[ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = ...
<     	GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
<     	             Xgrn5,Bgrn5,Ngrn5,sm5,sm5_abs,Aeq5,beq5,lb5,ub5,x05);
---
>         for ii = 1:flt5.num
>            cflt_name = flt5.name{ii};
>            % find subfaults for the master fault
>            sub_ind = strcmpi(cflt_name,subflt.name);
>            % find the boundary for fault 5
>            bnd_ind = strcmpi(cflt_name,bndry.name);
>            [ Xgrn5,Bgrn5,Ngrn5,sm5,sm5_abs,Aeq5,beq5,lb5,ub5,x05 ] = ...;
>     	   GTdef_fault5(flt5.flt,subflt.flt(sub_ind,:),bndry.bd(bnd_ind,:),pnt.crt,bsl.crt,nod.crt,rigidity,poisson,smooth,surf);
>            [ Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0 ] = ...
>     	   GTdef_addall(Xgrn,Bgrn,Ngrn,sm,sm_abs,Aeq,beq,lb,ub,x0,...
>     	                Xgrn5,Bgrn5,Ngrn5,sm5,sm5_abs,Aeq5,beq5,lb5,ub5,x05);
290c451
<     toc
---
> toc
293,297d453
< 
< %basename = strtok(fin_name,'.');	% noly works for names without "."
< cellname = regexp(fin_name,'\.in','split');
< basename = char(cellname(1));
< 
300c456
< fprintf(1,'\n.......... doing forward modeling ..........\t');
---
> fprintf(1,'\n........... doing forward modeling ..........\t');
304c460
<     fout_name = [ basename '_fwd.out' ];
---
>     foutName = [ basename '_fwd.out' ];
306,311c462,472
<     [ mod_info,pnt_out,bsl_out,nod_out ]...
<        = GTdef_forward(Xgrn,Bgrn,Ngrn,sm,sm_abs,lb,ub,x0,pnt_loc,pnt_obs,pnt_obs_err,pnt_wgt,bsl_loc,bsl_obs,bsl_obs_err,bsl_wgt,nod_loc,smooth);
<     GTdef_output(fout_name,'none','none',0,rigidity,poisson,flt1_name,flt1_num,flt1,flt2_name,flt2_num,flt2,flt3_name,flt3_num,flt3,...
< 	  	 flt4_name,flt4_num,flt4,{},0,[],{},[],...
< 		 subflt_name,subflt,dip_name,dip,pnt_name,pnt_num,pnt_out,bsl_name,bsl_num,bsl_out,...
<            	 prf_name,prf_num,prf,grd_name,grd_num,grd,nod_name,nod_out,mod_info);
---
>     [ mod_info,pnt.out,bsl.out,nod.out ] = GTdef_forward(Xgrn,Bgrn,Ngrn,sm,sm_abs,lb,ub,x0,pnt,bsl,nod,smooth);
>     if ~isempty(sspnt) || ~isempty(ssflt1) || ~isempty(ssflt2)
>         fstressName = [ basename '_stress.out' ];
>         [ sspnt,ssflt1,ssflt2 ] = GTdef_calc_stress(sspnt,ssflt1,ssflt2,Min0,earth,rigidity,poisson,edgrn,layer,edgrnfcts);
>         GTdef_output_stress(fstressName,sspnt,ssflt1,ssflt2);
>     end
>     % forward models do not change slips
>     flt1.out = flt1.flt; flt2.out = flt2.flt; flt3.out = flt3.flt; flt4.out = flt4.flt; 
>     subflt.out = subflt.flt; subflt.outname = subflt.name;
>     GTdef_output(foutName,coord,'none','none',0,rigidity,poisson,earth,edgrn,layer,...
>     		 flt1,flt2,flt3,flt4,flt5,bndry,subflt,dip,pnt,bsl,prf,grd,nod,mod_info);
321,351c482,510
<     beta_num = length(beta);
<     for ii = 1:beta_num
<     bt = beta(ii);
<     fprintf(1,'\n............. beta = %16.5f .............\t',bt);
<     tic
< 	if strcmp(smooth,'2d')
< 	    kp = sqrt(bt);
<             if kp>=1
<                 fout_name = strcat(basename,'_kp',num2str(kp,'%-.0f'),'.out');
< 	    else
<                 fout_name = strcat(basename,'_kp',num2str(kp,'%-.5f'),'.out');
< 	    end
< 	else
<             if bt>=1
<                 fout_name = strcat(basename,'_bt',num2str(bt,'%-.0f'),'.out');
< 	    else
<                 fout_name = strcat(basename,'_bt',num2str(bt,'%-.5f'),'.out');
< 	    end
< 	end
<         [ xx ] = GTdef_invert(Xgrn,Bgrn,sm_use,Aeq,beq,lb,ub,x0,pnt_obs,pnt_coef,bsl_obs,bsl_coef,bt);
< 	% faults info
<         [ flt1_out,flt2_out,subflt_name,subflt_out ]...
<           = GTdef_slips(lb,ub,xx,flt1_num,flt1,flt2_num,flt2,flt3_name,flt3_num,flt3,flt4_name,flt4_num,flt4,{},0,[]);
<         [ mod_info(ii,:),pnt_out,bsl_out,nod_out ]...
<           = GTdef_forward(Xgrn,Bgrn,Ngrn,sm_use,sm_abs,lb,ub,xx,pnt_loc,pnt_obs,pnt_obs_err,pnt_wgt,bsl_loc,bsl_obs,bsl_obs_err,bsl_wgt,nod_loc,smooth);
< 	% output results
<         GTdef_output(fout_name,smooth,surf,bt,rigidity,poisson,flt1_name,flt1_num,flt1_out,flt2_name,flt2_num,flt2_out,flt3_name,flt3_num,flt3,...
<               	     flt4_name,flt4_num,flt4,{},0,[],{},[],...
< 		     subflt_name,subflt_out,dip_name,dip,pnt_name,pnt_num,pnt_out,bsl_name,bsl_num,bsl_out,...
<                	     prf_name,prf_num,prf,grd_name,grd_num,grd,nod_name,nod_out,mod_info(ii,:));
<     toc
---
>     betaNum = length(beta);
>     for ii = 1:betaNum
>         bt = beta(ii);
>         fprintf(1,'\n............. beta = %16.5f .............\t',bt);
>         tic
>             if strcmp(smooth,'2d')
>                 kp = sqrt(bt);
>                 if kp>=1
>                     foutName = strcat(basename,'_kp',num2str(kp,'%-.0f'),'.out');
>                 else
>                     foutName = strcat(basename,'_kp',num2str(kp,'%-.5f'),'.out');
>                 end
>             else
>                 if bt>=1
>                     foutName = strcat(basename,'_bt',num2str(bt,'%-.0f'),'.out');
>                 else
>                     foutName = strcat(basename,'_bt',num2str(bt,'%-.5f'),'.out');
>                 end
>             end
>             [ xx ] = GTdef_invert(Xgrn,Bgrn,sm_use,Aeq,beq,lb,ub,x0,pnt,bsl,bt);
>             % faults info
>             [ flt1.out,flt2.out,flt3.out,flt4.out,subflt.out,subflt.outname ] = ...
> 	    GTdef_slips(lb,ub,xx,flt1,flt2,flt3,flt4,flt5,subflt);
>             [ mod_info(ii,:),pnt.out,bsl.out,nod.out ] = ...
> 	    GTdef_forward(Xgrn,Bgrn,Ngrn,sm_use,sm_abs,lb,ub,xx,pnt,bsl,nod,smooth);
>             % output results
>             GTdef_output(foutName,coord,smooth,surf,bt,rigidity,poisson,earth,edgrn,layer,...
>                          flt1,flt2,flt3,flt4,flt5,bndry,subflt,dip,pnt,bsl,prf,grd,nod,mod_info(ii,:));
>         toc
353,354c512,513
<     fout_sum = [ basename '_inv.out' ];
<     GTdef_summary(fout_sum,beta,mod_info);
---
>     fsumName = [ basename '_inv.out' ];
>     GTdef_summary(fsumName,beta,mod_info);
GTdef_open.m
2,11c2,129
<            flt1_name,flt1_num,flt1,...
< 	   flt2_name,flt2_num,flt2,...
<            flt3_name,flt3_num,flt3,...
< 	   flt4_name,flt4_num,flt4,...
< 	   flt5_name,flt5_num,flt5,...
< 	   bndry_name,bndry,subflt_name,subflt,dip_name,dip...
<            pnt_name,pnt_num,pnt_loc,pnt_disp,pnt_err,pnt_wgt,...
<            bsl_name,bsl_num,bsl_loc,bsl_disp,bsl_err,bsl_wgt,...
<            prf_name,prf_num,prf,...
< 	   grd_name,grd_num,grd ] = GTdef_open(filename)
---
> 	   earth,edgrn,layer,...
>            flt1,flt2,flt3,flt4,flt5,...
> 	   bndry,subflt,dip,...
>            pnt,bsl,prf,grd,...
> 	   sspnt,ssflt1,ssflt2 ] = GTdef_open(filename)
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                                  GTdef_open.m				                 %
> % The format of the input file could be very free  				         %
> % Just make sure the first term of each line is an identifiable flag 		         %
> % The program will ignore unidentifiable flags 					         %
> %										         %
> % The function reads in  							         %
> % (1) Parameters are not case sensitive						         %
> % 		coord         string                  {geo}			         %
> %                  geo   - geographic coordiante				         %
> % 		   geo_polyconic - geographic using polyconic projection                 %
> % 		   local - cartesian coordinate				                 %
> %               smooth	string		        {2d}				         %
> %         	   1d2pc - 1st derivative 2-point central			         %
> %         	   1d3pf - 1st derivative 3-point forward                                %
> %         	   1d3pb - 1st derivative 3-point backward                               %
> %            	      2d - 2nd derivative 3-point central                                %
> %               surf          string			{free}		   	         %
> %                  fixed - no free-surface					         %
> % 		   free  - assume free-surface				                 %
> %               kappa 	(1*kappa_num)		{0}				         %
> %               beta 	(1*beta_num)		{0}				         %
> % Note: beta is used to weight smoothing, usually for 1st derivative		         %
> %       kappa is used to weight smoothing, usually for 2nd derivative		         %
> %   If not provided by the input file, default values in {} will be used.                %
> %										         %
> % (2) Earth Structure:								         %
> % Either of the two types of earth structure can be used.			         %
> %  earth = homogeneous								         %
> %     		rigidity		(scalar)		{30e9 Pa}                %
> %		poisson			(scalar)		{0.25}		         %
> %  earth = layered		        					         %
> %		edgrn.nl        	(scalar)                                         %
> % 		edgrn.obsz     		(scalar)                                         %
> % 		edgrn.nr	        (scalar)                                         %
> % 		edgrn.minr,edgrn.maxr   (scalar)                                         %
> % 		edgrn.nz                (scalar)                                         %
> % 		edgrn.minz,edgrn.maxz   (scalar)                                         %
> %		edgrn.srate		(scalar)				         %
> %    		layer - [ id depth vp vs ro ]	(nn*5)				         %
> %		                                                                         %
> % (3) Faults:									         % 
> % read in four types of fault and subfault separately 				         %
> % each fault has a structure to store corresponding data			         %
> % flt? structure: flt?.name flt?.num flt?.flt					         %
> % subflt structure: subflt.name subflt.num & subflt.flt				         %
> %										         %
> % flt1.flt - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]        %
> % flt2.flt - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]      %
> %      subflt.flt - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		         %
> % flt3.flt - [lon1 lat1 z1 z2 len str dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]  %
> % flt4.flt - [lon1 lat1 lon2 lat2 z1 z2 dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]%
> %      subflt.flt - [ dnum snum rake rs ts rake0 rakeX rs0 rsX ts0 tsX ]                 %
> % dip structure: dip.name dip.num & dip.dip					         %
> % dip.dip  - [ dip z1 z2 rows ]	need to be used with dip.name			         %
> % bndry structure: bndry.name bndry.num & bndry.bd				         %
> %										         %
> % (4) Data:									         % 
> % Point: 									         %
> %		pnt.num  - number of point data			(scalar)	         %
> % 		pnt.name - names of point data			(cell array)	         %
> %		pnt.loc  - [lon lat z]				(nn*3)		         % 
> %   	 	pnt.disp - [east north vert]			(nn*3)                   %
> %   	 	pnt.err  - [east north vert]			(nn*3)                   %
> %   	 	pnt.wgt  - [weight]				(nn*1)                   % 
> % Baseline: 									         %
> % 		bsl.num  - number of baselines 			(scalar)	         %
> % 		bsl.name - names of baselines			(cell array)	         %
> % 		bsl.loc  - [lon1 lat1 z1 lon2 lat2 z2]		(nn*6)                   %
> %   		bsl.disp - [east north vert absolute]   	(nn*4)                   %
> %   		bsl.err  - [east north vert absolute]   	(nn*4)                   %
> %   		bsl.wgt  - [weight]                     	(nn*1)                   %
> % Profile:									         %
> % 		prf.num  - number of profiles 			(scalar)	         %
> % 		prf.name - names of profiles			(cell array)	         %
> % 		prf.prf  - [lon1 lat1 lon2 lat2 N]		(nn*5)                   %
> % Grd:										         %
> % 		grd.num  - number of grids 			(scalar)	         %
> % 		grd.name - names of grids			(cell array)	         %
> %		grd.grd  - [Erot Nrot lon1 lat1 lon2 lat2 Ne Nn](nn*8)                   %
> %										         %
> % (5) Stress:                                                                            %
> % Point:                                                                                 %
> %             sspnt.num  - number of points for stress calculation (scalar)              %
> %             sspnt.name - names of points                      (cell array)             %
> %             sspnt.loc  - [lon lat z]                          (nn*3)                   %
> %             sspnt.str  - [strike]                             (nn*1)                   %
> %             sspnt.dip  - [dip]                                (nn*1)                   %
> %             sspnt.rake - [rake]                               (nn*1)                   %
> % 	      sspnt.fric - [friction]                           (nn*1)                   %
> % Fault:                                                                                 %
> %            ssflt?.fltnum  - number of faults for stress calculation  (scalar)          %    
> %            ssflt?.fltname - names of faults                   (cell array)             %
> %            ssflt?.flt  - fault parameters                     (flt_num*11)             %
> %              									         %
> %            ssflt1.flt = [lon1 lat1 z1   z2   len str dip rake fric Nd Ns]              %
> %            ssflt2.flt = [lon1 lat1 lon2 lat2 z1  z2  dip rake fric Nd Ns]              %
> %                                                                                        %
> % Note: 									         %
> %   Longitude can be input as [0 360] or [-180 180]. The program will convert 	         %
> %   [0 360] to [-180 180] internally.						         %
> %   If weight is not assigned, default weight is 1 for all the data.		         %
> %										         %
> % first created by Lujia Feng Apr 2009					                 %
> % added 'coord' flag for coordinate type lfeng Thu Nov  5 20:43:53 EST 2009	         %
> % added 'smooth' flag for smoothing lfeng Wed Dec  2 02:26:17 EST 2009 		         %
> % added 'beta' flag for smoothing lfeng Wed Dec  2 23:23:21 EST 2009		         %
> % added 'dip' flag for bended fault lfeng Mon Dec  7 00:53:06 EST 2009		         %
> % added 'freesurface' flag lfeng Wed Dec  9 17:06:48 EST 2009			         %
> % added 'fault5' lfeng Fri Dec 11 12:38:41 EST 2009				         %
> % changed 'freesurface' to 'surface' flag lfeng Wed Feb 24 12:46:01 EST 2010	         %
> % changed 'coord' to string flag lfeng Wed Feb 24 13:40:01 EST 2010		         %
> % use cell array of strings for names lfeng Wed Dec  1 14:41:46 EST 2010	         %
> % commented out 'fault5' lfeng Wed Dec  1 14:42:53 EST 2010			         %
> % added layered earth structure lfeng Mon Feb 20 17:16:32 SGT 2012                       %
> % used structures to simplify parameters lfeng Mon Feb 20 17:30:59 SGT 2012              %
> % merged fault1 & fault3 and fault2 & fault4 lfeng Tue May  8 16:20:25 SGT 2012          %
> % created new fault3 & fault4 for rake lfeng Tue May  8 18:35:44 SGT 2012                %
> % added stress lfeng Thu May 17 07:41:29 SGT 2012                                        %
> % added polyconic projection lfeng Thu Jun  7 13:43:28 SGT 2012                          %
> % last modified by Lujia FENG Mon Jun 11 12:30:00 SGT 2012                               %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
13,79c131
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %                               GTdef_open.m				        %
< % 		  function to open the input file for GTdef		        %
< %										%
< % The format of the input file could be very free. 				%
< % Just make sure the first term of each line is an identifiable flag.		%
< % The program will ignore unidentifiable flags.					%
< %										%
< % The function reads in  							%
< % (1) Parameters are not case sensitive						%
< % 		  coord         string                  {geo}			%
< %                      geo   - geographic coordiante				%
< % 		       local - cartesian coordinate				%
< %                 smooth	string		        {2d}			%
< %         	   1d2pc - 1st derivative 2-point central			%
< %         	   1d3pf - 1st derivative 3-point forward                       %
< %         	   1d3pb - 1st derivative 3-point backward                      %
< %            	      2d - 2nd derivative 3-point central                       %
< %                 surf          string			{free}		   	%
< %                      fixed - no free-surface					%
< % 		       free  - assume free-surface				%
< %                 kappa 	(1*kappa_num)		{0}			%
< %                 beta 		(1*beta_num)		{0}			%
< % Note: beta is used to weight smoothing, usually for 1st derivative		%
< %       kappa^2 is used to weight smoothing, usually for 2nd derivative		%
< %     		  rigidity	scalar			{30e9 Pa}               %
< %		  poisson	scalar			{0.25}			%
< %   If not provided by the input file, default values in {} will be used.       %
< %										%
< % (2) Faults:									% 
< % Four types of fault and subfault will be read in separately.			%
< %  flt1 - [lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]     	%
< %  flt2 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]   	%
< %  flt3 - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]	%
< %  flt4 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]%
< %  subflt - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		  	%
< %  dip  - [ dnum  dip ] need to be used with dip_name				%
< %										%
< % (3) Data:									% 
< % Point: 	pnt_loc  - [lon lat z]				(nn*3)		% 
< %   	 	pnt_disp - [east north vert]			(nn*3)          %
< %   	 	pnt_err  - [east north vert]			(nn*3)          %
< %   	 	pnt_wgt  - [weight]				(nn*1)          % 
< % Baseline: 	bsl_loc  - [lon1 lat1 z1 lon2 lat2 z2]		(nn*6)          %
< %   		bsl_disp - [east north vert absolute]   	(nn*4)          %
< %   		bsl_err  - [east north vert absolute]   	(nn*4)          %
< %   		bsl_wgt  - [weight]                     	(nn*1)          %
< % Profile:	prf - [lon1 lat1 lon2 lat2 N]			(nn*5)          %
< % Grd:		grd - [Erot Nrot lon1 lat1 lon2 lat2 Ne Nn] 	(nn*8)          %
< % Note: 									%
< %   Longitude can be input as [0 360] or [-180 180]. The program will convert 	%
< %   [0 360] to [-180 180] internally.						%
< %   If weight is not assigned, default weight is 1 for all the data.		%
< %										%
< % first created by Lujia Feng Apr 2009					        %
< % added 'coord' flag for coordinate type lfeng Thu Nov  5 20:43:53 EST 2009	%
< % added 'smooth' flag for smoothing lfeng Wed Dec  2 02:26:17 EST 2009 		%
< % added 'beta' flag for smoothing lfeng Wed Dec  2 23:23:21 EST 2009		%
< % added 'dip' flag for bended fault lfeng Mon Dec  7 00:53:06 EST 2009		%
< % added 'freesurface' flag lfeng Wed Dec  9 17:06:48 EST 2009			%
< % added 'fault5' lfeng Fri Dec 11 12:38:41 EST 2009				%
< % changed 'freesurface' to 'surface' flag lfeng Wed Feb 24 12:46:01 EST 2010	%
< % changed 'coord' to string flag lfeng Wed Feb 24 13:40:01 EST 2010		%
< % use cell array of strings for names lfeng Wed Dec  1 14:41:46 EST 2010	%
< % commented out 'fault5' lfeng Wed Dec  1 14:42:53 EST 2010			%
< % last modified by Lujia Feng Wed Dec  1 14:52:00 EST 2010			%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
---
> if ~exist(filename,'file'), error('GTdef_open ERROR: %s does not exist!',filename); end
88a141,143
> earth = 'homogeneous';
> edgrn = [];
> layer = [];
92,103c147,161
< flt1_num = 0;  	 flt1_name = {};    flt1 = []; 
< flt2_num = 0;    flt2_name = {};    flt2 = []; 
< flt3_num = 0;    flt3_name = {};    flt3 = []; 
< flt4_num = 0;    flt4_name = {};    flt4 = []; 
< flt5_num = 0;    flt5_name = {};    flt5 = []; 
< bndry_num = 0;   bndry_name = {};   bndry= [];
< subflt_num = 0;  subflt_name = {};  subflt = []; 
< dip_num = 0;     dip_name = {};     dip = [];
< pnt_num = 0;     pnt_name = {};     pnt_loc = []; pnt_disp = []; pnt_err = []; pnt_wgt = []; 
< bsl_num = 0;     bsl_name = {};     bsl_loc = []; bsl_disp = []; bsl_err = []; bsl_wgt = []; 
< prf_num = 0;     prf_name = {};     prf = []; 
< grd_num = 0;     grd_name = {};     grd = [];
---
> flt1.num = 0;  	 flt1.name = {};    flt1.flt = []; 
> flt2.num = 0;    flt2.name = {};    flt2.flt = []; 
> flt3.num = 0;    flt3.name = {};    flt3.flt = []; 
> flt4.num = 0;    flt4.name = {};    flt4.flt = []; 
> flt5.num = 0;    flt5.name = {};    flt5.flt = []; 
> bndry.num  = 0;  bndry.name  = {};  bndry.bd   = [];
> subflt.num = 0;  subflt.name = {};  subflt.flt = []; 
> dip.num = 0;     dip.name = {};     dip.dip = [];
> pnt.num = 0;     pnt.name = {};     pnt.loc = [];   pnt.disp = [];  pnt.err = [];   pnt.wgt = []; 
> bsl.num = 0;     bsl.name = {};     bsl.loc = [];   bsl.disp = [];  bsl.err = [];   bsl.wgt = []; 
> prf.num = 0;     prf.name = {};     prf.prf = []; 
> grd.num = 0;     grd.name = {};     grd.grd = [];
> sspnt.num  = 0;  sspnt.name  = {};  sspnt.loc  = []; sspnt.str = []; sspnt.dip = []; sspnt.rake = []; sspnt.fric = [];
> ssflt1.fltnum = 0;  ssflt1.num = 0;  ssflt1.fltname = {};  ssflt1.flt = []; 
> ssflt2.fltnum = 0;  ssflt2.num = 0;  ssflt2.fltname = {};  ssflt2.flt = []; 
106c164,165
< beta_num = 0;
---
> beta_num  = 0;
> layer_num = 0;
121a181,183
> 	if ~strcmpi(coord,'geo') && ~strcmpi(coord,'geo_polyconic') && ~strcmpi(coord,'local')
>             error('GTdef_open ERROR: coordinate system should be either geo, geo_polyconic or local!');
> 	end
126a189,191
> 	if ~strcmpi(smooth,'none') && ~strcmpi(smooth,'2d') && ~strcmpi(smooth,'1d2pc') && ~strcmpi(smooth,'1d3pf') && ~strcmpi(smooth,'1d3pb')
>             error('GTdef_open ERROR: smooth algorithm should be 2d, 1d2pc, 1d3pf or 1d3pb!');
> 	end
131a197,199
> 	if ~strcmpi(surf,'none') && ~strcmpi(surf,'free') && ~strcmpi(surf,'fixed')
>             error('GTdef_open ERROR: surfce should be either free or fixed!');
> 	end
188,191c256,281
<     %%%%% rigidity %%%%%
<     if strcmpi(flag,'rigidity')
<  	[ rigidity,remain ] = GTdef_read1double(remain);
< 	continue
---
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Earth Structures %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>     %%%%% earth structure %%%%%
>     if strcmpi(flag,'earth')
> 	[earth,remain] = strtok(remain);
>         %%%%% homogeneous OKADA %%%%%
>         if strcmpi(earth,'homogeneous')||strcmpi(earth,'homo')
>             [ rigidity,remain ] = GTdef_read1double(remain);
> 	    [ poisson,remain ]  = GTdef_read1double(remain);
> 	    earth = 'homogeneous';
>             continue
>         end
>         %%%%% layered EDGRN/EDCMP %%%%%
>         if strcmpi(earth,'layered');
>             [ edgrn.nl,remain ]    = GTdef_read1double(remain);
> 	    [ edgrn.obsz,remain ]  = GTdef_read1double(remain);
>             [ edgrn.nr,remain ]    = GTdef_read1double(remain);
>             [ edgrn.minr,remain ]  = GTdef_read1double(remain);
>             [ edgrn.maxr,remain ]  = GTdef_read1double(remain);
>             [ edgrn.nz,remain ]    = GTdef_read1double(remain);
>             [ edgrn.minz,remain ]  = GTdef_read1double(remain);
>             [ edgrn.maxz,remain ]  = GTdef_read1double(remain);
>             [ edgrn.srate,remain ] = GTdef_read1double(remain);
>             continue
>         end
>         error('GTdef_open ERROR: earth model should be either homogeneous or layered!');
193,195c283,288
<     %%%%% poisson %%%%%
<     if strcmpi(flag,'poisson')
<  	[ poisson,remain ] = GTdef_read1double(remain);
---
>     %%%%% layers %%%%%
>     if strcmpi(flag,'layer')
>         layer_num = layer_num+1;
> 	for ii = 1:5
>  	    [ layer(layer_num,ii),remain ] = GTdef_read1double(remain);
> 	end
206,208c299,301
< 	    flt1_num = flt1_num+1; flt1_name = [ flt1_name; name ];
< 	    for ii = 1:16
<  		[ flt1(flt1_num,ii),remain ] = GTdef_read1double(remain);
---
> 	    flt1.num = flt1.num+1; flt1.name = [ flt1.name; name ];
> 	    for ii = 1:18
>  		[ flt1.flt(flt1.num,ii),remain ] = GTdef_read1double(remain);
214,217c307,310
<         [name,remain] = strtok(remain);
< 	    flt2_num = flt2_num+1; flt2_name = [ flt2_name; name ];
< 	    for ii = 1:16
<  		[ flt2(flt2_num,ii),remain ] = GTdef_read1double(remain);
---
>             [name,remain] = strtok(remain);
> 	    flt2.num = flt2.num+1; flt2.name = [ flt2.name; name ];
> 	    for ii = 1:18
>  		[ flt2.flt(flt2.num,ii),remain ] = GTdef_read1double(remain);
223,224c316,317
<         [name,remain] = strtok(remain);
< 	    flt3_num = flt3_num+1; flt3_name = [ flt3_name; name ];
---
>             [name,remain] = strtok(remain);
> 	    flt3.num = flt3.num+1; flt3.name = [ flt3.name; name ];
226c319
<  		[ flt3(flt3_num,ii),remain ] = GTdef_read1double(remain);
---
>  		[ flt3.flt(flt3.num,ii),remain ] = GTdef_read1double(remain);
232,233c325,326
<         [name,remain] = strtok(remain);
< 	    flt4_num = flt4_num+1; flt4_name = [ flt4_name; name ];
---
>             [name,remain] = strtok(remain);
> 	    flt4.num = flt4.num+1; flt4.name = [ flt4.name; name ];
235c328
<  		[ flt4(flt4_num,ii),remain ] = GTdef_read1double(remain);
---
>  		[ flt4.flt(flt4.num,ii),remain ] = GTdef_read1double(remain);
242c335
< 	%    flt5_num = flt5_num+1; flt5_name = [ flt5_name; name ];
---
> 	%    flt5.num = flt5.num+1; flt5.name = [ flt5.name; name ];
244c337
<  	%	[ flt5(flt5_num,ii),remain ] = GTdef_read1double(remain);
---
>  	%	[ flt5.flt(flt5.num,ii),remain ] = GTdef_read1double(remain);
253c346
< 	subflt_num = subflt_num+1; subflt_name = [ subflt_name; name ];
---
> 	subflt.num = subflt.num+1; subflt.name = [ subflt.name; name ];
255c348
<  	    [ subflt(subflt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	    [ subflt.flt(subflt.num,ii),remain ] = GTdef_read1double(remain);
262c355
<     %    bndry_num = bndry_num+1; bndry_name = [ bndry_name; name ];
---
>     %    bndry.num = bndry.num+1; bndry.name = [ bndry.name; name ];
264c357
<     %        [ bndry(bndry_num,ii),remain ] = GTdef_read1double(remain);
---
>     %        [ bndry.bd(bndry.num,ii),remain ] = GTdef_read1double(remain);
271c364
< 	dip_num = dip_num+1; dip_name = [ dip_name; name ];
---
> 	dip.num = dip.num+1; dip.name = [ dip.name; name ];
273c366
<  	    [ dip(dip_num,ii),remain ] = GTdef_read1double(remain);
---
>  	    [ dip.dip(dip.num,ii),remain ] = GTdef_read1double(remain);
276a370
> 
284c378
<             pnt_num = pnt_num+1; pnt_name = [ pnt_name; name ];
---
>             pnt.num = pnt.num+1; pnt.name = [ pnt.name; name ];
287c381
<  	        [ pnt_loc(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.loc(pnt.num,ii),remain ] = GTdef_read1double(remain);
290,291c384,385
< 	    pnt_disp(pnt_num,1) = nan; pnt_disp(pnt_num,2) = nan;
<  	    [ pnt_disp(pnt_num,3),remain ] = GTdef_read1double(remain);
---
> 	    pnt.disp(pnt.num,1) = nan; pnt.disp(pnt.num,2) = nan;
>  	    [ pnt.disp(pnt.num,3),remain ] = GTdef_read1double(remain);
293,294c387,388
< 	    pnt_err(pnt_num,1) = nan; pnt_err(pnt_num,2) = nan;
<  	    [ pnt_err(pnt_num,3),remain ] = GTdef_read1double(remain);
---
> 	    pnt.err(pnt.num,1) = nan; pnt.err(pnt.num,2) = nan;
>  	    [ pnt.err(pnt.num,3),remain ] = GTdef_read1double(remain);
298c392
< 	        pnt_wgt(pnt_num,1) = 1;
---
> 	        pnt.wgt(pnt.num,1) = 1;
300c394
<                 pnt_wgt(pnt_num,1) = str2double(str);
---
>                 pnt.wgt(pnt.num,1) = str2double(str);
307c401
<             pnt_num = pnt_num+1; pnt_name = [ pnt_name; name ];
---
>             pnt.num = pnt.num+1; pnt.name = [ pnt.name; name ];
310c404
<  	        [ pnt_loc(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.loc(pnt.num,ii),remain ] = GTdef_read1double(remain);
314c408
<  	        [ pnt_disp(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.disp(pnt.num,ii),remain ] = GTdef_read1double(remain);
316c410
< 	    pnt_disp(pnt_num,3) = nan;
---
> 	    pnt.disp(pnt.num,3) = nan;
319c413
<  	        [ pnt_err(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.err(pnt.num,ii),remain ] = GTdef_read1double(remain);
321c415
< 	    pnt_err(pnt_num,3) = nan;
---
> 	    pnt.err(pnt.num,3) = nan;
325c419
< 	        pnt_wgt(pnt_num,1) = 1;
---
> 	        pnt.wgt(pnt.num,1) = 1;
327c421
<                 pnt_wgt(pnt_num,1) = str2double(str);
---
>                 pnt.wgt(pnt.num,1) = str2double(str);
334c428
<             pnt_num = pnt_num+1; pnt_name = [ pnt_name; name ];
---
>             pnt.num = pnt.num+1; pnt.name = [ pnt.name; name ];
337c431
<  	        [ pnt_loc(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.loc(pnt.num,ii),remain ] = GTdef_read1double(remain);
341c435
<  	        [ pnt_disp(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.disp(pnt.num,ii),remain ] = GTdef_read1double(remain);
345c439
<  	        [ pnt_err(pnt_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ pnt.err(pnt.num,ii),remain ] = GTdef_read1double(remain);
350c444
< 	        pnt_wgt(pnt_num,1) = 1;
---
> 	        pnt.wgt(pnt.num,1) = 1;
352c446
<                 pnt_wgt(pnt_num,1) = str2double(str);
---
>                 pnt.wgt(pnt.num,1) = str2double(str);
364c458
<             bsl_num = bsl_num+1; bsl_name = [ bsl_name; name ];
---
>             bsl.num = bsl.num+1; bsl.name = [ bsl.name; name ];
367c461
<  	        [ bsl_loc(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.loc(bsl.num,ii),remain ] = GTdef_read1double(remain);
370,371c464,465
< 	    bsl_disp(bsl_num,1) = nan; bsl_disp(bsl_num,2) = nan; bsl_disp(bsl_num,3) = nan;
<  	    [ bsl_disp(bsl_num,4),remain ] = GTdef_read1double(remain);
---
> 	    bsl.disp(bsl.num,1) = nan; bsl.disp(bsl.num,2) = nan; bsl.disp(bsl.num,3) = nan;
>  	    [ bsl.disp(bsl.num,4),remain ] = GTdef_read1double(remain);
373,374c467,468
< 	    bsl_err(bsl_num,1) = nan; bsl_err(bsl_num,2) = nan; bsl_err(bsl_num,3) = nan;
<  	    [ bsl_err(bsl_num,4),remain ] = GTdef_read1double(remain);
---
> 	    bsl.err(bsl.num,1) = nan; bsl.err(bsl.num,2) = nan; bsl.err(bsl.num,3) = nan;
>  	    [ bsl.err(bsl.num,4),remain ] = GTdef_read1double(remain);
378c472
< 	        bsl_wgt(bsl_num,1) = 1;
---
> 	        bsl.wgt(bsl.num,1) = 1;
380c474
<                 bsl_wgt(bsl_num,1) = str2double(str);
---
>                 bsl.wgt(bsl.num,1) = str2double(str);
387c481
<             bsl_num = bsl_num+1; bsl_name = [ bsl_name; name ];
---
>             bsl.num = bsl.num+1; bsl.name = [ bsl.name; name ];
390c484
<  	        [ bsl_loc(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.loc(bsl.num,ii),remain ] = GTdef_read1double(remain);
394c488
<  	        [ bsl_disp(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.disp(bsl.num,ii),remain ] = GTdef_read1double(remain);
396c490
< 	    bsl_disp(bsl_num,4) = nan;
---
> 	    bsl.disp(bsl.num,4) = nan;
399c493
<  	        [ bsl_err(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.err(bsl.num,ii),remain ] = GTdef_read1double(remain);
401c495
< 	    bsl_err(bsl_num,4) = nan;
---
> 	    bsl.err(bsl.num,4) = nan;
405c499
< 	        bsl_wgt(bsl_num,1) = 1;
---
> 	        bsl.wgt(bsl.num,1) = 1;
407c501
<                 bsl_wgt(bsl_num,1) = str2double(str);
---
>                 bsl.wgt(bsl.num,1) = str2double(str);
414c508
<             bsl_num = bsl_num+1; bsl_name = [ bsl_name; name ];
---
>             bsl.num = bsl.num+1; bsl.name = [ bsl.name; name ];
417c511
<  	        [ bsl_loc(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.loc(bsl.num,ii),remain ] = GTdef_read1double(remain);
421c515
<  	        [ bsl_disp(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.disp(bsl.num,ii),remain ] = GTdef_read1double(remain);
425c519
<  	        [ bsl_err(bsl_num,ii),remain ] = GTdef_read1double(remain);
---
>  	        [ bsl.err(bsl.num,ii),remain ] = GTdef_read1double(remain);
430c524
< 	        bsl_wgt(bsl_num,1) = 1;
---
> 	        bsl.wgt(bsl.num,1) = 1;
432c526
<                 bsl_wgt(bsl_num,1) = str2double(str);
---
>                 bsl.wgt(bsl.num,1) = str2double(str);
441c535
< 	prf_num = prf_num+1; prf_name = [ prf_name; name ];
---
> 	prf.num = prf.num+1; prf.name = [ prf.name; name ];
443c537
<  	    [ prf(prf_num,ii),remain ] = GTdef_read1double(remain);
---
>  	    [ prf.prf(prf.num,ii),remain ] = GTdef_read1double(remain);
450c544
< 	grd_num = grd_num+1; grd_name = [ grd_name; name ];
---
> 	grd.num = grd.num+1; grd.name = [ grd.name; name ];
452c546
<  	    [ grd(grd_num,ii),remain ] = GTdef_read1double(remain);
---
>  	    [ grd.grd(grd.num,ii),remain ] = GTdef_read1double(remain);
455a550,593
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Stress Calculation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>     if strcmpi(flag,'stress')
>         [type,remain] = strtok(remain);
>         %%%%% point %%%%%
>         if strcmpi(type,'point')
>             [name,remain] = strtok(remain);
>             sspnt.num = sspnt.num+1; sspnt.name = [ sspnt.name; name ];
>             %% point location [lon lat z] %%
>             for ii = 1:3
>                 [ sspnt.loc(sspnt.num,ii),remain ] = GTdef_read1double(remain);
>             end
>             %% point fault parameters %%
>             [ sspnt.str(sspnt.num,1),remain ]  = GTdef_read1double(remain);
>             [ sspnt.dip(sspnt.num,1),remain ]  = GTdef_read1double(remain);
>             [ sspnt.rake(sspnt.num,1),remain ] = GTdef_read1double(remain);
>             [ sspnt.fric(sspnt.num,1),remain ] = GTdef_read1double(remain);
>             continue
>         end
>         %%%%% fault %%%%%
>         if strcmpi(type,'fault')
>             [method,remain] = strtok(remain);
>             %% fault 1 %%
>             if strcmp(method,'1')
>                 [name,remain]  = strtok(remain);
>                 ssflt1.fltnum  = ssflt1.fltnum+1;
>                 ssflt1.fltname = [ ssflt1.fltname; name ];
>                 for ii = 1:11
>                     [ ssflt1.flt(ssflt1.fltnum,ii),remain ] = GTdef_read1double(remain);
>                 end
>                 continue
>             end
>             %% fault 2 %%
>             if strcmp(method,'2')
>                 [name,remain]  = strtok(remain);
>                 ssflt2.fltnum  = ssflt2.fltnum+1;
>                 ssflt2.fltname = [ ssflt2.fltname; name ];
>                 for ii = 1:11
>                     [ ssflt2.flt(ssflt2.fltnum,ii),remain ] = GTdef_read1double(remain);
>                 end
>                 continue
>             end
>         end
>     end
468,472c606,610
< if strcmpi(coord,'geo')
<    if flt1_num~=0, [ flt1(:,1) ] = GTdef_convertlon(flt1(:,1)); end
<    if flt2_num~=0
<        [ flt2(:,1) ] = GTdef_convertlon(flt2(:,1));
<        [ flt2(:,3) ] = GTdef_convertlon(flt2(:,3));
---
> if strcmpi(coord,'geo') || strcmpi(coord,'geo_polyconic')
>    if flt1.num~=0, [ flt1.flt(:,1) ] = GTdef_convertlon(flt1.flt(:,1)); end
>    if flt2.num~=0
>        [ flt2.flt(:,1) ] = GTdef_convertlon(flt2.flt(:,1));
>        [ flt2.flt(:,3) ] = GTdef_convertlon(flt2.flt(:,3));
474,477c612,615
<    if flt3_num~=0, [ flt3(:,1) ] = GTdef_convertlon(flt3(:,1)); end
<    if flt4_num~=0
<        [ flt4(:,1) ] = GTdef_convertlon(flt4(:,1));
<        [ flt4(:,3) ] = GTdef_convertlon(flt4(:,3));
---
>    if flt3.num~=0, [ flt3.flt(:,1) ] = GTdef_convertlon(flt3.flt(:,1)); end
>    if flt4.num~=0
>        [ flt4.flt(:,1) ] = GTdef_convertlon(flt4.flt(:,1));
>        [ flt4.flt(:,3) ] = GTdef_convertlon(flt4.flt(:,3));
479,482c617,620
<    if pnt_num~=0, [ pnt_loc(:,1) ] = GTdef_convertlon(pnt_loc(:,1)); end
<    if bsl_num~=0
<        [ bsl_loc(:,1) ] = GTdef_convertlon(bsl_loc(:,1));
<        [ bsl_loc(:,4) ] = GTdef_convertlon(bsl_loc(:,4));
---
>    if pnt.num~=0, [ pnt.loc(:,1) ] = GTdef_convertlon(pnt.loc(:,1)); end
>    if bsl.num~=0
>        [ bsl.loc(:,1) ] = GTdef_convertlon(bsl.loc(:,1));
>        [ bsl.loc(:,4) ] = GTdef_convertlon(bsl.loc(:,4));
484,486c622,624
<    if prf_num~=0
<        [ prf(:,1) ] = GTdef_convertlon(prf(:,1));
<        [ prf(:,3) ] = GTdef_convertlon(prf(:,3));
---
>    if prf.num~=0
>        [ prf.prf(:,1) ] = GTdef_convertlon(prf.prf(:,1));
>        [ prf.prf(:,3) ] = GTdef_convertlon(prf.prf(:,3));
488,490c626,628
<    if grd_num~=0
<        [ grd(:,3) ] = GTdef_convertlon(grd(:,3));
<        [ grd(:,5) ] = GTdef_convertlon(grd(:,5));
---
>    if grd.num~=0
>        [ grd.grd(:,3) ] = GTdef_convertlon(grd.grd(:,3));
>        [ grd.grd(:,5) ] = GTdef_convertlon(grd.grd(:,5));
493a632,636
> % if layer exists, sort layer according to the ascending id
> if ~isempty(layer)
>    layer = sortrows(layer,1);
> end
> 
506c649
<     error('The input file is wrong!');
---
>     error('GTdef_open ERROR: The input file is wrong!');
GTdef_output.m
1,73c1,90
< function [] = GTdef_output(filename,smooth,surf,beta,rigidity,poisson,...
<            		   flt1_name,flt1_num,flt1,...
< 	  		   flt2_name,flt2_num,flt2,...
<           		   flt3_name,flt3_num,flt3,...
< 	  		   flt4_name,flt4_num,flt4,...
< 	  		   flt5_name,flt5_num,flt5,...
< 			   bndry_name,bndry,...
< 	  		   subflt_name,subflt,dip_name,dip,...
<           		   pnt_name,pnt_num,pnt_out,...
<           		   bsl_name,bsl_num,bsl_out,...
<            		   prf_name,prf_num,prf,...
< 	   		   grd_name,grd_num,grd,...
< 	  		   nod_name,nod_out,mod_info)
< 
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %                             GTdef_output.m				        %
< % 		  function to output the model results				%
< %										%
< % INPUT:									%
< % (1) Parameters: 								%
< %  beta 	scalar								%
< %  rigidity	scalar			{30e9 Pa}               		%
< %  poisson	scalar			{0.25}					%
< %										%
< % (2) Faults:									% 
< %  flt1 - [lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]     	%
< %  flt2 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]  	%
< %  flt3 - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]	%
< %  flt4 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]%
< %  subflt_out - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		  	%
< %  dip  - [ dip z1 z2 rows ]						        %
< %										%
< % (3) Data:									% 
< %  mod_info = [ data_num slip_num ndf rss rms wrrs wrms chi2 rchi2            	%
< %               r_1d r_2d strain ]				  		%
< %     slip_num - number of free slips					  	%
< %     data_num - number of data points (not including nan)                 	%
< %     ndf      - number of degrees of freedom                              	%
< %  Note: since if we introduce smoothing, slips are not independent	  	%  
< %  we don't really know the real ndf.					  	%
< %     rss      - residual sum of squares [m^2]                                  %
< %     rms      - root mean square of rss [m]                                  	%
< %     wrss     - weighted residual sum of squares [m^2]			  	%
< %     wrms     = sqrt(wrss/data_num) [m]					%
< %     chi2     - chi-square                                                	%
< %     rchi2    - reduced chi-square                                        	%
< %     r_1d     - the average 1st derivative sum of each patch [cm/km]		%
< %                depends on the finite difference method used		  	%
< %     r_2d     - the average 2nd derivative sum of each patch		        %
< %                (eq. 5 in Jonsson_etal_BSSA_2002) [cm/km^2]		        %
< %                 r represents roughness					%
< %    strain   - average strain of each patch [cm/km]				%
< %                (absolute value of 1st derivaitves)			  	%
< %  pnt_out  - [lon lat zz Ue Un Uv eUe eUn eUv weight]                    	%
< %  bsl_out  - [lon1 lat1 z1 lon2 lat2 z2 Ue Un Uv Ul eUe eUn eUv eUl wgt] 	%
< %  nod_out  - [lon lat zz Ue Un Uv eUe eUn eUv weight]			  	%
< %										%
< % OUTPUT: an output file                                                        %
< %                                                                               %
< % first created by Lujia Feng Wed May  6 20:58:39 EDT 2009			%
< % added beta lfeng Wed Dec  2 23:42:51 EST 2009					%
< % added 1st derivative r_1d lfeng Thu Dec  3 01:27:48 EST 2009			%
< % added flag 'dip' by lfeng Mon Dec  7 01:05:28 EST 2009		  	%
< % added fault5 by lfeng Fri Dec 11 13:00:11 EST 2009				%
< % corrected the wrong 'freesurface' flag and changed it to 'surface' flag	%
< %    lfeng Wed Feb 24 13:26:18 EST 2010					        %
< % added the units in the output	lfeng Wed Jul 21 17:06:07 EDT 2010		%
< % use cell array of strings for names lfeng Wed Dec  1 17:36:42 EST 2010	%
< % use 4 digits after . for slip constraints lfeng Thu Dec  9 03:52:06 EST 2010  %
< % test existence before output lfeng Thu Apr 14 12:58:16 EDT 2011		%
< % last modified by Lujia Feng Thu Apr 14 13:23:49 EDT 2011			%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< 
---
> function [] = GTdef_output(filename,...
> 			   coord,smooth,surf,beta,rigidity,poisson,...
> 		           earth,edgrn,layer,...
>            		   flt1,flt2,flt3,flt4,flt5,...   
> 			   bndry,subflt,dip,...
>           		   pnt,bsl,prf,grd,nod,mod_info)
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                             GTdef_output.m				                 %
> % 		  function to output the model results				         %
> %										         %
> % INPUT:									         %
> % (1) Controlling Parameters: 							         %
> %  coord        (string)                {geo}					         %
> %  smooth	(string)		{2d}					         %
> %  surf         (string)		{free}		   			         %
> %  beta 	(scalar)							         %
> %										         %
> % (2) Earth Structure:								         %
> % Either of the two types of earth structure can be used.			         %
> %  earth = homogeneous								         %
> %     		rigidity		(scalar)		{30e9 Pa}                %
> %		poisson			(scalar)		{0.25}		         %
> %  earth = layered		        					         %
> %		edgrn.nl        	(scalar)                                         %
> % 		edgrn.obsz     		(scalar)                                         %
> % 		edgrn.nr	        (scalar)                                         %
> % 		edgrn.minr,edgrn.maxr   (scalar)                                         %
> % 		edgrn.nz                (scalar)                                         %
> % 		edgrn.minz,edgrn.maxz   (scalar)                                         %
> %		edgrn.srate		(scalar)				         %	
> %    		layer - [ id depth vp vs ro ]	(nn*5)				         %
> %										         %
> % (3) Faults:									         % 
> % each fault has a structure to store corresponding data			         %
> % flt? structure: flt?.name flt?.num flt?.flt					         %
> % subflt structure: subflt.name subflt.num subflt.flt subflt.out subflt.outname	         %
> % flt1.flt - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]        %
> % flt2.flt - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]      %
> %      subflt.flt - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		  	 %
> % flt3.flt - [lon1 lat1 z1 z2 len str dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns ] %
> % flt4.flt - [lon1 lat1 lon2 lat2 z1 z2 dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]%
> %      subflt.flt - [ dnum snum rake rs ts rake0 rakeX rs0 rsX ts0 tsX ]                 %
> % dip structure: dip.name dip.num & dip.dip					         %
> % dip.dip  - [ dip z1 z2 rows ]						                 %
> % bndry structure: bndry.name bndry.num & bndry.bd				         %
> % OUTPUT: flt1.out flt2.out subflt.out subflt.outname				         %
> %										         %
> % (4) Data:									         % 
> %  mod_info = [ data_num slip_num ndf rss rms wrrs wrms chi2 rchi2            	         %
> %               r_1d r_2d strain ]				  		         %
> %     slip_num - number of free slips					  	         %
> %     data_num - number of data points (not including nan)                 	         %
> %     ndf      - number of degrees of freedom                              	         %
> %  Note: since if we introduce smoothing, slips are not independent	  	         %  
> %  we don't really know the real ndf.					  	         %
> %     rss      - residual sum of squares [m^2]                                           %
> %     rms      - root mean square of rss [m]                                  	         %
> %     wrss     - weighted residual sum of squares [m^2]			  	         %
> %     wrms     = sqrt(wrss/data_num) [m]					         %
> %     chi2     - chi-square                                                	         %
> %     rchi2    - reduced chi-square                                        	         %
> %     r_1d     - the average 1st derivative sum of each patch [cm/km]		         %
> %                depends on the finite difference method used		  	         %
> %     r_2d     - the average 2nd derivative sum of each patch		                 %
> %                (eq. 5 in Jonsson_etal_BSSA_2002) [cm/km^2]		                 %
> %                 r represents roughness					         %
> %    strain   - average strain of each patch [cm/km]				         %
> %                (absolute value of 1st derivaitves)			  	         %
> %  pnt.out  - [lon lat zz Ue Un Uv eUe eUn eUv weight]                    	         %
> %  bsl.out  - [lon1 lat1 z1 lon2 lat2 z2 Ue Un Uv Ul eUe eUn eUv eUl wgt] 	         %
> %  nod.out  - [lon lat zz Ue Un Uv eUe eUn eUv weight]			  	         %
> %										         %
> % OUTPUT: an output file                                                                 %
> %                                                                                        %
> % first created by Lujia Feng Wed May  6 20:58:39 EDT 2009			         %
> % added beta lfeng Wed Dec  2 23:42:51 EST 2009					         %
> % added 1st derivative r_1d lfeng Thu Dec  3 01:27:48 EST 2009			         %
> % added flag 'dip' by lfeng Mon Dec  7 01:05:28 EST 2009		  	         %
> % added fault5 by lfeng Fri Dec 11 13:00:11 EST 2009				         %
> % corrected the wrong 'freesurface' flag and changed it to 'surface' flag	         %
> %    lfeng Wed Feb 24 13:26:18 EST 2010					                 %
> % added the units in the output	lfeng Wed Jul 21 17:06:07 EDT 2010		         %
> % use cell array of strings for names lfeng Wed Dec  1 17:36:42 EST 2010	         %
> % use 4 digits after . for slip constraints lfeng Thu Dec  9 03:52:06 EST 2010           %
> % test existence before output lfeng Thu Apr 14 12:58:16 EDT 2011		         %
> % used structure & added layered output lfeng Wed Feb 22 14:31:31 SGT 2012	         %
> % merged fault1 & fault3 and fault2 & fault4 lfeng Thu May 10 17:03:16 SGT 2012          %
> % last modified by Lujia Feng Sun May 13 13:07:21 SGT 2012                               %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
78a96
>     fprintf(fout,'\n');
80c98,99
< %%%%%%%%%% parameters %%%%%%%%%%
---
> 
> %%%%%%%%%% smooth parameters %%%%%%%%%%
83,86c102
<     fprintf(fout,'kappa   \t%-12.5f\nbeta     \t%-12.5f\n',kappa,beta);
< end
< if ~isempty(rigidity)
<     fprintf(fout,'rigidity\t%-10.2e\n',rigidity);
---
>     fprintf(fout,'kappa   \t%-12.5f\nbeta     \t%-12.5f\n\n',kappa,beta);
88,89c104,118
< if ~isempty(poisson)
<     fprintf(fout,'poisson \t%-6.4f\n',poisson);
---
> 
> %%%%%%%%%% earth model %%%%%%%%%%
> if strcmpi(earth,'homogeneous')||strcmpi(earth,'homo')
>     fprintf(fout,'earth\thomogeneous\t%-10.2e\t%-6.4f\n',rigidity,poisson);
>     fprintf(fout,'\n');
> elseif strcmpi(earth,'layered')
>     fprintf(fout,'earth\tlayered   %.0f %-8.4e  %.0f %-8.4e %-8.4e  %.0f %-8.4e %-8.4e   %.4f\n',...
>             edgrn.nl,edgrn.obsz,edgrn.nr,edgrn.minr,edgrn.maxr,edgrn.nz,edgrn.minz,edgrn.maxz,edgrn.srate);
>     fprintf(fout,'\n');
> end
> 
> %%%%%%%%%% layers %%%%%%%%%%
> if ~isempty(layer)
>     fprintf(fout,'layer   %.0f   %8.4e  %-8.4e  %-8.4e  %-8.4e\n',layer');
>     fprintf(fout,'\n');
92a122,124
> if ~isempty(coord)
>     fprintf(fout,'coord   \t%s\n',coord);
> end
98a131
> fprintf(fout,'\n');
101,102c134,143
< for ii =1:flt1_num
<     fprintf(fout,'fault 1 %s  %-14.8f %-12.8f %-6.4e %12.4e %-12.4e %-5.2f %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt1_name{ii},flt1(ii,:));
---
> % note: output flt1.out
> for ii =1:flt1.num
>     flt_name = flt1.name{ii};
>     fprintf(fout,'fault 1 %s  %-14.8f %-12.8f %-6.4e %12.4e %-12.4e %-5.2f %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt1.out(ii,:));
>     ind = strcmpi(flt_name,subflt.outname);
>     num = sum(ind);
>     subflt1 = subflt.out(ind,:);
>     for jj = 1:num
>         fprintf(fout,'     subfault %s  %5d %5d  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt1(jj,:));
>     end
106,107c147,156
< for ii =1:flt2_num
<     fprintf(fout,'fault 2 %s  %-14.8f %-12.8f %14.8f %-12.8f %12.4e %-12.4e %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt2_name{ii},flt2(ii,:));
---
> % note: output flt2.out
> for ii =1:flt2.num
>     flt_name = flt2.name{ii};
>     fprintf(fout,'fault 2 %s  %-14.8f %-12.8f %14.8f %-12.8f %12.4e %-12.4e %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt2.out(ii,:));
>     ind = strcmpi(flt_name,subflt.outname);
>     num = sum(ind);
>     subflt2 = subflt.out(ind,:);
>     for jj = 1:num
>         fprintf(fout,'     subfault %s  %5d %5d  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt2(jj,:));
>     end
111,118c160,167
< for ii =1:flt3_num
<     flt_name = flt3_name{ii};
<     fprintf(fout,'fault 3 %s  %-14.8f %-12.8f %-6.4e %12.4e %-12.4e %-5.2f %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt3(ii,:));
<     ind = strcmpi(flt_name,subflt_name);
<     subflt_num = sum(ind);
<     subflt3 = subflt(ind,:);
<     for jj = 1:subflt_num
<         fprintf(fout,'     subfault %s  %5d %5d  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt3(jj,:));
---
> for ii =1:flt3.num
>     flt_name = flt3.name{ii};
>     fprintf(fout,'fault 3 %s  %-14.8f %-12.8f %-6.4e %12.4e %-12.4e %-5.2f %-5.2f  %10.2f %-8.5f %-8.5f  %-7.2f %-7.2f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt3.out(ii,:));
>     ind = strcmpi(flt_name,subflt.outname);
>     num = sum(ind);
>     subflt3 = subflt.out(ind,:);
>     for jj = 1:num
>         fprintf(fout,'     subfault %s  %5d %5d  %10.2f %-8.5f %-8.5f  %-7.2f %-7.2f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt3(jj,:));
123,130c172,179
< for ii =1:flt4_num
<     flt_name = flt4_name{ii};
<     fprintf(fout,'fault 4 %s  %-14.8f %-12.8f %14.8f %-12.8f %12.4e %-12.4e %-5.2f  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt4(ii,:));
<     ind = strcmpi(flt_name,subflt_name);
<     subflt_num = sum(ind);
<     subflt4 = subflt(ind,:);
<     for jj = 1:subflt_num
<         fprintf(fout,'     subfault %s  %5d %5d  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt4(jj,:));
---
> for ii =1:flt4.num
>     flt_name = flt4.name{ii};
>     fprintf(fout,'fault 4 %s  %-14.8f %-12.8f %14.8f %-12.8f %12.4e %-12.4e %-5.2f  %10.2f %-8.5f %-8.5f  %-7.2f %-7.2f  %-5.4f %-5.4f  %-5.4f %-5.4f    %d %d\n',flt_name,flt4.out(ii,:));
>     ind = strcmpi(flt_name,subflt.outname);
>     num = sum(ind);
>     subflt4 = subflt.out(ind,:);
>     for jj = 1:num
>         fprintf(fout,'     subfault %s  %5d %5d  %10.2f %-8.5f %-8.5f  %-7.2f %-7.2f  %-5.4f %-5.4f  %-5.4f %-5.4f\n',flt_name,subflt4(jj,:));
135,141c184,191
< for ii =1:flt5_num
<     flt_name = flt5_name(ii,:);
<     fprintf(fout,'fault 5 %s  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f   %d  %d  %-5.2f  %-5.2f\n',flt_name,flt5(ii,:));
<     ind = strcmpi(flt_name,subflt_name);
<     subflt_num = sum(ind);
<     subflt5 = subflt(ind,:);
<     for jj = 1:subflt_num
---
> % if flt5.num = 0, the following code won't execute!
> for ii =1:flt5.num
>     flt_name = flt5.name(ii,:);
>     fprintf(fout,'fault 5 %s  %10.5f %-8.5f %-8.5f  %-5.4f %-5.4f  %-5.4f %-5.4f  %-5.4f %-5.4f   %d  %d  %-5.2f  %-5.2f\n',flt_name,flt5.flt(ii,:));
>     ind = strcmpi(flt_name,subflt.outname);
>     num = sum(ind);
>     subflt5 = subflt.out(ind,:);
>     for jj = 1:num
144,147c194,197
<     ind = strcmpi(flt_name,bndry_name);
<     bndry_num = sum(ind);
<     bndry5 = bndry(ind,:);
<     for jj = 1:bndry_num
---
>     ind = strcmpi(flt_name,bndry.name);
>     num = sum(ind);
>     bndry5 = bndry.bd(ind,:);
>     for jj = 1:num
153,155c203,204
< num = size(dip,1);
< for ii =1:num
<     fprintf(fout,'dip   %s  %8.4f  %-12.4e  %-12.4e  %-d\n',dip_name{ii},dip(ii,:));
---
> for ii =1:dip.num
>     fprintf(fout,'dip   %s  %8.4f  %-12.4e  %-12.4e  %-d\n',dip.name{ii},dip.dip(ii,:));
159,160c208,209
< for ii =1:pnt_num
<     fprintf(fout,'point 3 %s     %-14.8f %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n', pnt_name{ii},pnt_out(ii,:));
---
> for ii =1:pnt.num
>     fprintf(fout,'point 3 %s\t%14.8f   %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n', pnt.name{ii},pnt.out(ii,:));
164,165c213,214
< for ii =1:bsl_num
<     fprintf(fout,'baseline 3 %s     %-14.8f %-12.8f %-6.4e  %14.8f %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f %-8.5f  %5.2f\n', bsl_name{ii},bsl_out(ii,:));
---
> for ii =1:bsl.num
>     fprintf(fout,'baseline 3 %s\t%14.8f   %-12.8f %-6.4e  %14.8f %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f %-8.5f  %5.2f\n', bsl.name{ii},bsl.out(ii,:));
169,170c218,219
< for ii =1:prf_num
<     name = prf_name{ii};
---
> for ii =1:prf.num
>     name = prf.name{ii};
172,178c221,227
<     fprintf(fout,'#profile %s  %-14.8f %-12.8f  %14.8f %-12.8f    %d\n',name,prf(ii,:));
<     ind = strncmpi(name,nod_name,name_len);
<     nod_num = sum(ind); 
<     cnod_name = nod_name(ind);
<     cnod_out = nod_out(ind,:);
<     for jj = 1:nod_num
<     	fprintf(fout,'point 3 %s     %-14.8f %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n',cnod_name{jj},cnod_out(jj,:));
---
>     fprintf(fout,'#profile %s  %-14.8f %-12.8f  %14.8f %-12.8f    %d\n',name,prf.prf(ii,:));
>     ind = strncmpi(name,nod.name,name_len);
>     num = sum(ind); 
>     cnod_name = nod.name(ind);
>     cnod_out  = nod.out(ind,:);
>     for jj = 1:num
>     	fprintf(fout,'point 3 %s\t%14.8f   %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n',cnod_name{jj},cnod_out(jj,:));
183,184c232,233
< for ii =1:grd_num
<     name = grd_name{ii};
---
> for ii =1:grd.num
>     name = grd.name{ii};
186,192c235,241
<     fprintf(fout,'#grid %s %-5.2f %-5.2f  %14.8f %-12.8f  %10.4f %-8.4f    %d  %d\n',name,grd(ii,:));
<     ind = strncmpi(name,nod_name,name_len);
<     nod_num = sum(ind); 
<     cnod_name = nod_name(ind);
<     cnod_out = nod_out(ind,:);
<     for jj = 1:nod_num
<     	fprintf(fout,'point 3 %s     %-14.8f %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n',cnod_name{jj},cnod_out(jj,:));
---
>     fprintf(fout,'#grid %s %-5.2f %-5.2f    %12.8f %-12.8f  %10.4f %-8.4f    %d  %d\n',name,grd.grd(ii,:));
>     ind = strncmpi(name,nod.name,name_len);
>     num = sum(ind); 
>     cnod_name = nod.name(ind);
>     cnod_out  = nod.out(ind,:);
>     for jj = 1:num
>     	fprintf(fout,'point 3 %s\t%14.8f   %-12.8f %-6.4e  %10.5f %-8.5f %-8.5f  %8.5f %-8.5f %-8.5f  %-5.2f\n',cnod_name{jj},cnod_out(jj,:));
GTdef_prjfault1_EW.m
diff: v2/GTdef_prjfault1_EW.m: No such file or directory
GTdef_prjfault1.m
diff: v2/GTdef_prjfault1.m: No such file or directory
GTdef_prjfault2_EW.m
diff: v2/GTdef_prjfault2_EW.m: No such file or directory
GTdef_prjfault2.m
diff: v2/GTdef_prjfault2.m: No such file or directory
GTdef_prjfault3_EW.m
diff: v2/GTdef_prjfault3_EW.m: No such file or directory
GTdef_prjfault3.m
diff: v2/GTdef_prjfault3.m: No such file or directory
GTdef_prjfault4_EW.m
diff: v2/GTdef_prjfault4_EW.m: No such file or directory
GTdef_prjfault4.m
diff: v2/GTdef_prjfault4.m: No such file or directory
GTdef_prjpnt.m
1c1
< function [ ] = GTdef_prjpnt(fout,pnt_name,pnt_loc,pnt_crt,pnt_disp,pnt_err,pnt_wgt,flt_type,flt_name,flt)
---
> function [ ] = GTdef_prjpnt(fout,pnt,flt_type,flt_name,flt)
3,33c3,31
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %                               GTdef_prjpnt				  %
< % Project point location onto the fault surface coordinate		  %
< % only works for fault1,fault2, and master fault of fault3,fault4	  %
< %									  %
< % INPUT:					  		  	  %
< %  fout - output file handle						  %
< %  fault1 & fault3							  %
< %  flt = [ xx yy z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX ]     %
< %  fault2 & fault4							  %
< %  flt = [ x1 y1 x2 y2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX ]       %
< %  input coordinate is cartesian					  %
< %                                                                         %
< % OUTPUT: (output to a file, the format is)				  %
< % [ point 3 pnt_name lon lat z Ue Un Uv eUe eUn eUv weight 		  %
< %   flt_name Dstr1 Dstr2 Ddip Dvert ]					  %
< %    Dstr1 - distance along fault strike from endpoint 1		  %
< %            strike direction is positive				  %
< %    Dstr2 - distance along fault strike from endpoint 2		  %
< %            strike direction is negative				  %
< %    Ddip - distance along fault dip from the fault axis		  %
< %    Dvert - distance vertically to the fault plane			  %
< %                                                                         %
< % related functions:							  %
< % GTdef_prjfault1.m; GTdef_prjfault2.m; 				  %
< % GTdef_prjfault3.m; GTdef_prjfault4.m					  %
< % first created by Lujia Feng Fri May  1 14:15:53 EDT 2009		  %
< % use cell array of strings for names lfeng Wed Dec  1 15:19:07 EST 2010  %
< % added Dstr2 lfeng Fri Dec 10 14:40:19 EST 2010			  %
< % last modified by Lujia Feng Fri Dec 10 14:52:13 EST 2010		  %
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
---
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                                GTdef_prjpnt				        %
> % Project point location onto the fault surface coordinate		        %
> % only works for master fault of fault1, fault2, fault3, and fault4	        %
> %									        %
> % INPUT:					  		  	        %
> % fout - output file handle						        %
> % flt1 = [xx yy z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]       %
> % flt2 = [x1 y1 x2 y2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]         %
> % flt3 = [xx yy z1 z2 len str dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns] %
> % flt4 = [x1 y1 x2 y2 z1 z2 dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]   %
> %    input coordinate is cartesian					        %
> %                                                                               %
> % OUTPUT: (output to a file, the format is)				        %
> % [ point 3 pnt.name lon lat z Ue Un Uv eUe eUn eUv weight 		        %
> %   flt_name Dstr1 Dstr2 Ddip Dvert ]					        %
> %    Dstr1 - distance along fault strike from endpoint 1		        %
> %            strike direction is positive				        %
> %    Dstr2 - distance along fault strike from endpoint 2		        %
> %            strike direction is negative				        %
> %    Ddip - distance along fault dip from the fault axis		        %
> %    Dvert - distance vertically to the fault plane			        %
> %                                                                               %
> % first created by Lujia Feng Fri May  1 14:15:53 EDT 2009		        %
> % use cell array of strings for names lfeng Wed Dec  1 15:19:07 EST 2010        %
> % added Dstr2 lfeng Fri Dec 10 14:40:19 EST 2010			        %
> % used structure lfeng Thu Feb 23 10:21:11 SGT 2012			        %
> % last modified by Lujia Feng Thu Feb 23 10:21:20 SGT 2012		        %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
36c34,36
< if datanum~=16&&datanum~=18, error('need a n*16 or n*18 fault vector for GTdef_prjpnt'); end
---
> if datanum~=18  
>     error('GTdef_prjpnt ERROR: need a n*18 fault vector as input!'); 
> end
39d38
< pnt_num = size(pnt_loc,1);		% point num
42c41
< pnt_out = [ pnt_loc pnt_disp pnt_err pnt_wgt ];
---
> pnt_out = [ pnt.loc pnt.disp pnt.err pnt.wgt ];
55c54
< for ii = 1:pnt_num
---
> for ii = 1:pnt.num
58,59c57,58
<     xx = pnt_crt(ii,1)*ones(flt_num,1);
<     yy = pnt_crt(ii,2)*ones(flt_num,1); 
---
>     xx = pnt.crt(ii,1)*ones(flt_num,1);
>     yy = pnt.crt(ii,2)*ones(flt_num,1); 
69c68
<         fprintf(fout,'point 3 %s %-14.8f %-12.8f %-6.4e %10.5f %-10.5f %-10.5f %8.5f %-8.5f %-8.5f %-5.2f %s %12.4e %12.4e %12.4e %12.4e\n',pnt_name{ii},pnt_cur,flt_name{jj},Dstr1(jj),Dstr2(jj),Ddip(jj),Dvert(jj));
---
>         fprintf(fout,'point 3 %s %-14.8f %-12.8f %-6.4e %10.5f %-10.5f %-10.5f %8.5f %-8.5f %-8.5f %-5.2f %s %12.4e %12.4e %12.4e %12.4e\n',pnt.name{ii},pnt_cur,flt_name{jj},Dstr1(jj),Dstr2(jj),Ddip(jj),Dvert(jj));
GTdef_profile.m
GTdef_project_EW.m
diff: v2/GTdef_project_EW.m: No such file or directory
GTdef_project.m
4c4
< %                       GTdef_project.m                                  	% 
---
> %                       	GTdef_project.m                                 % 
41c41,44
< % last modified by lfeng Sun Apr 10 17:12:54 EDT 2011				%
---
> % used structure lfeng Thu Feb 23 10:12:16 SGT 2012				%
> % merged fault1 & fault3 and fault2 & fault4 lfeng Sun May 13 23:41:32 SGT 2012 %
> % added polyconic projection lfeng Thu Jun  7 13:27:43 SGT 2012                 %
> % last modified by lfeng Wed Jun 13 16:00:57 SGT 2012                           %
44d46
< 
48,55c50,52
<  [ coord,smooth,fsurf,beta,rigidity,poisson,... 
<    flt1_name,flt1_num,flt1,flt2_name,flt2_num,flt2,...
<    flt3_name,flt3_num,flt3,flt4_name,flt4_num,flt4,... 
<    ~,~,~,~,~,...
<    subflt_name,subflt,dip_name,dip,...
<    pnt_name,pnt_num,pnt_loc,pnt_disp,pnt_err,pnt_wgt,... 
<    bsl_name,bsl_num,bsl_loc,bsl_disp,bsl_err,bsl_wgt,...
<    prf_name,prf_num,prf, grd_name,grd_num,grd ] = GTdef_open(fin_name);
---
> [ coord,~,~,~,~,~,~,~,~,...
>   flt1,flt2,flt3,flt4,flt5,...
>   ~,subflt,dip,pnt,~,~,~,~,~,~ ] = GTdef_open(fin_name);
60c57
< if strcmpi(coord,'geo')
---
> if strcmpi(coord,'geo') || strcmpi(coord,'geo_polyconic')
62,63c59,60
<    if flt1_num~=0
<        lonlist = [ lonlist;flt1(:,1) ]; latlist = [ latlist;flt1(:,2) ];
---
>    if flt1.num~=0
>        lonlist = [ lonlist;flt1.flt(:,1) ]; latlist = [ latlist;flt1.flt(:,2) ];
65,66c62,63
<    if flt2_num~=0
<        lonlist = [ lonlist;flt2(:,1) ]; latlist = [ latlist;flt2(:,2) ];
---
>    if flt2.num~=0
>        lonlist = [ lonlist;flt2.flt(:,1) ]; latlist = [ latlist;flt2.flt(:,2) ];
68,69c65,66
<    if flt3_num~=0
<        lonlist = [ lonlist;flt3(:,1) ]; latlist = [ latlist;flt3(:,2) ];
---
>    if flt3.num~=0
>        lonlist = [ lonlist;flt3.flt(:,1) ]; latlist = [ latlist;flt3.flt(:,2) ];
71,72c68,69
<    if flt4_num~=0
<        lonlist = [ lonlist;flt4(:,1) ]; latlist = [ latlist;flt4(:,2) ];
---
>    if flt4.num~=0
>        lonlist = [ lonlist;flt4.flt(:,1) ]; latlist = [ latlist;flt4.flt(:,2) ];
77c74
<     error('Coordinate input is wrong!!!');
---
>     error('GTdef_project ERROR: Coordinate input is wrong!!!');
84a82,83
> pnt.crt = [];
> if pnt.num~=0
87,88d85
< pnt_crt = [];
< if pnt_num~=0
91c88,91
<        [pxx,pyy] = LL2ckmd(pnt_loc(:,1),pnt_loc(:,2),lon0,lat0,0);
---
>        [pxx,pyy] = LL2ckmd(pnt.loc(:,1),pnt.loc(:,2),lon0,lat0,0);
>     end
>     if strcmpi(coord,'geo_polyconic')
>        [pxx,pyy] = latlon_to_xy(pnt.loc(:,1),pnt.loc(:,2),lon0,lat0);
94c94
<        pxx = pnt_loc(:,1); pyy = pnt_loc(:,2);
---
>        pxx = pnt.loc(:,1); pyy = pnt.loc(:,2);
97c97
<     pnt_crt = [pxx pyy pzz];                   	% cartesian - 3*n matrix [xx;yy;zz]; it is just Xin
---
>     pnt.crt = [pxx pyy pzz];                   	% cartesian - 3*n matrix [xx;yy;zz]; it is just Xin
103d102
< end
104a104
> end
108c108,110
< prjflt = []; flt_name = {}; prjflt1 = []; prjflt2 = []; prjflt3 = []; prjflt4 = [];
---
> prjflt12 = []; flt_name12 = {}; 
> prjflt34 = []; flt_name34 = {};
> prjflt1  = []; prjflt2 = []; prjflt3 = []; prjflt4 = [];
110c112
< if flt1_num~=0
---
> if flt1.num~=0
114c116,119
<        [x1,y1] = LL2ckmd(flt1(:,1),flt1(:,2),lon0,lat0,0);
---
>        [x1,y1] = LL2ckmd(flt1.flt(:,1),flt1.flt(:,2),lon0,lat0,0);
>     end
>     if strcmpi(coord,'geo_polyconic')
>        [x1,y1] = latlon_to_xy(flt1.flt(:,1),flt1.flt(:,2),lon0,lat0);
117c122,144
<        x1 = flt1(:,1); y1 = flt1(:,2);
---
>        x1 = flt1.flt(:,1); y1 = flt1.flt(:,2);
>     end
>     newflt1 = [ x1 y1 flt1.flt(:,3:end) ];
>     if ~isempty(pnt.crt)
>        GTdef_prjpnt(fpnt,pnt,1,flt1.name,newflt1);
>     end
>     for ii = 1:flt1.num
>        Nd = flt1.flt(ii,17); Ns = flt1.flt(ii,18); flt_num = Nd*Ns;
>        cflt_name = flt1.name{ii};
>        % find the subfaults for the master fault
>        sub_ind = strcmpi(cflt_name,subflt.name);
>        % find dips for the master fault
>        dip_ind = strcmpi(cflt_name,dip.name);
>        % cross-section projection
>        [ xsect1_name,xsect1 ] = GTdef_xsection(1,cflt_name,newflt1(ii,:),dip.dip(dip_ind,:));
>        xsect = [ xsect; xsect1 ];
>        xsect_name = [ xsect_name; xsect1_name ];   
>        % surface projection
>        [ ~,prjflt1,~,~ ] = GTdef_prjflt1dif(newflt1(ii,:),subflt.flt(sub_ind,:),dip.dip(dip_ind,:));
>        prjflt12 = [ prjflt12; prjflt1 ];
>        name1 = cell(flt_num,1);
>        for ii = 1:flt_num, name1{ii} = cflt_name; end
>        flt_name12 = [ flt_name12; name1 ];   
119,129d145
<     newflt1 = [ x1 y1 flt1(:,3:end) ];
<     [ xsect1_name,xsect1 ] = GTdef_xsection(1,flt1_name,newflt1,[]);
<     xsect = [ xsect; xsect1 ];
<     xsect_name = [ xsect_name; xsect1_name ];   
<     if ~isempty(pnt_crt)
<        GTdef_prjpnt(fpnt,pnt_name,pnt_loc,pnt_crt,pnt_disp,pnt_err,pnt_wgt,1,flt1_name,newflt1);
<     end
<     newflt1 = [ zeros(flt1_num,2) x1 y1 flt1(:,3:end) ];
<     [ prjflt1 ] = GTdef_prjfault1(newflt1);
<     prjflt = [ prjflt; prjflt1 ];
<     flt_name = [ flt_name; flt1_name ];   
134c150
< if flt2_num~=0
---
> if flt2.num~=0
138,139c154,159
<        [x2_1,y2_1] = LL2ckmd(flt2(:,1),flt2(:,2),lon0,lat0,0);
<        [x2_2,y2_2] = LL2ckmd(flt2(:,3),flt2(:,4),lon0,lat0,0);
---
>        [x2_1,y2_1] = LL2ckmd(flt2.flt(:,1),flt2.flt(:,2),lon0,lat0,0);
>        [x2_2,y2_2] = LL2ckmd(flt2.flt(:,3),flt2.flt(:,4),lon0,lat0,0);
>     end
>     if strcmpi(coord,'geo_polyconic')
>        [x2_1,y2_1] = latlon_to_xy(flt2.flt(:,1),flt2.flt(:,2),lon0,lat0);
>        [x2_2,y2_2] = latlon_to_xy(flt2.flt(:,3),flt2.flt(:,4),lon0,lat0);
142,143c162,183
<        x2_1 = flt2(:,1); y2_1 = flt2(:,2);
<        x2_2 = flt2(:,3); y2_2 = flt2(:,4);
---
>        x2_1 = flt2.flt(:,1); y2_1 = flt2.flt(:,2);
>        x2_2 = flt2.flt(:,3); y2_2 = flt2.flt(:,4);
>     end
>     newflt2 = [ x2_1 y2_1 x2_2 y2_2 flt2.flt(:,5:end) ];
>     if ~isempty(pnt.crt)
>        GTdef_prjpnt(fpnt,pnt,2,flt2.name,newflt2);
>     end
>     for ii = 1:flt2.num
>        Nd = flt2.flt(ii,17); Ns = flt2.flt(ii,18); flt_num = Nd*Ns;
>        cflt_name = flt2.name{ii};
>        % find the subfaults for the master fault
>        sub_ind = strcmpi(cflt_name,subflt.name);
>        % find dips for the master fault
>        dip_ind = strcmpi(cflt_name,dip.name);
>        [ xsect2_name,xsect2 ] = GTdef_xsection(2,cflt_name,newflt2(ii,:),dip.dip(dip_ind,:));
>        xsect = [ xsect; xsect2 ];
>        xsect_name = [ xsect_name; xsect2_name ];   
>        [ ~,prjflt2,~,~ ] = GTdef_prjflt2dif(newflt2(ii,:),subflt.flt(sub_ind,:),dip.dip(dip_ind,:));
>        prjflt12 = [ prjflt12; prjflt2 ];
>        name2 = cell(flt_num,1);
>        for ii = 1:flt_num, name2{ii} = cflt_name; end
>        flt_name12 = [ flt_name12; name2 ];   
145,155d184
<     newflt2 = [ x2_1 y2_1 x2_2 y2_2 flt2(:,5:end) ];
<     [ xsect2_name,xsect2 ] = GTdef_xsection(2,flt2_name,newflt2,[]);
<     xsect = [ xsect; xsect2 ];
<     xsect_name = [ xsect_name; xsect2_name ];   
<     if ~isempty(pnt_crt)
<        GTdef_prjpnt(fpnt,pnt_name,pnt_loc,pnt_crt,pnt_disp,pnt_err,pnt_wgt,2,flt2_name,newflt2);
<     end
<     newflt2 = [ zeros(flt2_num,2) x2_1 y2_1 x2_2 y2_2 flt2(:,5:end) ];
<     [ prjflt2 ] = GTdef_prjfault2(newflt2);
<     prjflt = [ prjflt; prjflt2 ];
<     flt_name = [ flt_name; flt2_name ];   
160c189
< if flt3_num~=0
---
> if flt3.num~=0
164c193
<        [x3,y3] = LL2ckmd(flt3(:,1),flt3(:,2),lon0,lat0,0);
---
>        [x3,y3] = LL2ckmd(flt3.flt(:,1),flt3.flt(:,2),lon0,lat0,0);
166,167c195,196
<     if strcmpi(coord,'local')
<        x3 = flt3(:,1); y3 = flt3(:,2);
---
>     if strcmpi(coord,'geo_polyconic')
>        [x3,y3] = latlon_to_xy(flt3.flt(:,1),flt3.flt(:,2),lon0,lat0);
169,171c198,199
<     newflt3 = [x3 y3 flt3(:,3:end)];
<     if ~isempty(pnt_crt)
<        GTdef_prjpnt(fpnt,pnt_name,pnt_loc,pnt_crt,pnt_disp,pnt_err,pnt_wgt,3,flt3_name,newflt3);
---
>     if strcmpi(coord,'local')
>        x3 = flt3.flt(:,1); y3 = flt3.flt(:,2);
173,175c201,207
<     for ii = 1:flt3_num
<        Nd = flt3(ii,17); Ns = flt3(ii,18); flt_num = Nd*Ns;
<        cflt_name = flt3_name{ii};
---
>     newflt3 = [x3 y3 flt3.flt(:,3:end)];
>     if ~isempty(pnt.crt)
>        GTdef_prjpnt(fpnt,pnt,3,flt3.name,newflt3);
>     end
>     for ii = 1:flt3.num
>        Nd = flt3.flt(ii,17); Ns = flt3.flt(ii,18); flt_num = Nd*Ns;
>        cflt_name = flt3.name{ii};
177c209
<        sub_ind = strcmpi(cflt_name,subflt_name);
---
>        sub_ind = strcmpi(cflt_name,subflt.name);
179,180c211,212
<        dip_ind = strcmpi(cflt_name,dip_name);
<        [ xsect3_name,xsect3 ] = GTdef_xsection(3,cflt_name,newflt3(ii,:),dip(dip_ind,:));
---
>        dip_ind = strcmpi(cflt_name,dip.name);
>        [ xsect3_name,xsect3 ] = GTdef_xsection(3,cflt_name,newflt3(ii,:),dip.dip(dip_ind,:));
183,184c215,216
<        [ prjflt3 ] = GTdef_prjfault3(newflt3(ii,:),subflt(sub_ind,:),dip(dip_ind,:));
<        prjflt = [ prjflt; prjflt3 ];
---
>        [ ~,prjflt3,~,~ ] = GTdef_prjflt3dif(newflt3(ii,:),subflt.flt(sub_ind,:),dip.dip(dip_ind,:));
>        prjflt34 = [ prjflt34; prjflt3 ];
187c219
<        flt_name = [ flt_name; name3 ];   
---
>        flt_name34 = [ flt_name34; name3 ];   
193c225
< if flt4_num~=0
---
> if flt4.num~=0
197,198c229,230
<        [x4_1,y4_1] = LL2ckmd(flt4(:,1),flt4(:,2),lon0,lat0,0);
<        [x4_2,y4_2] = LL2ckmd(flt4(:,3),flt4(:,4),lon0,lat0,0);
---
>        [x4_1,y4_1] = LL2ckmd(flt4.flt(:,1),flt4.flt(:,2),lon0,lat0,0);
>        [x4_2,y4_2] = LL2ckmd(flt4.flt(:,3),flt4.flt(:,4),lon0,lat0,0);
200,202c232,234
<     if strcmpi(coord,'local')
<        x4_1 = flt4(:,1); y4_1 = flt4(:,2);
<        x4_2 = flt4(:,3); y4_2 = flt4(:,4);
---
>     if strcmpi(coord,'geo_polyconic')
>        [x4_1,y4_1] = latlon_to_xy(flt4.flt(:,1),flt4.flt(:,2),lon0,lat0);
>        [x4_2,y4_2] = latlon_to_xy(flt4.flt(:,3),flt4.flt(:,4),lon0,lat0);
204,206c236,238
<     newflt4 = [x4_1 y4_1 x4_2 y4_2 flt4(:,5:end)];
<     if ~isempty(pnt_crt)
<        GTdef_prjpnt(fpnt,pnt_name,pnt_loc,pnt_crt,pnt_disp,pnt_err,pnt_wgt,4,flt4_name,newflt4);
---
>     if strcmpi(coord,'local')
>        x4_1 = flt4.flt(:,1); y4_1 = flt4.flt(:,2);
>        x4_2 = flt4.flt(:,3); y4_2 = flt4.flt(:,4);
208,210c240,246
<     for ii = 1:flt4_num
<        Nd = flt4(ii,17); Ns = flt4(ii,18); flt_num = Nd*Ns;
<        cflt_name = flt4_name{ii};
---
>     newflt4 = [x4_1 y4_1 x4_2 y4_2 flt4.flt(:,5:end)];
>     if ~isempty(pnt.crt)
>        GTdef_prjpnt(fpnt,pnt,4,flt4.name,newflt4);
>     end
>     for ii = 1:flt4.num
>        Nd = flt4.flt(ii,17); Ns = flt4.flt(ii,18); flt_num = Nd*Ns;
>        cflt_name = flt4.name{ii};
212c248
<        sub_ind = strcmpi(cflt_name,subflt_name);
---
>        sub_ind = strcmpi(cflt_name,subflt.name);
214,215c250,251
<        dip_ind = strcmpi(cflt_name,dip_name);
<        [ xsect4_name,xsect4 ] = GTdef_xsection(4,cflt_name,newflt4(ii,:),dip(dip_ind,:));
---
>        dip_ind = strcmpi(cflt_name,dip.name);
>        [ xsect4_name,xsect4 ] = GTdef_xsection(4,cflt_name,newflt4(ii,:),dip.dip(dip_ind,:));
218,219c254,255
<        [ prjflt4 ] = GTdef_prjfault4(newflt4(ii,:),subflt(sub_ind,:),dip(dip_ind,:));
<        prjflt = [ prjflt; prjflt4 ];
---
>        [ ~,prjflt4,~,~ ] = GTdef_prjflt4dif(newflt4(ii,:),subflt.flt(sub_ind,:),dip.dip(dip_ind,:));
>        prjflt34 = [ prjflt34; prjflt4 ];
222c258
<        flt_name = [ flt_name; name4 ];   
---
>        flt_name34 = [ flt_name34; name4 ];   
226,237c262
< if ~isempty(pnt_crt), fclose(fpnt); end
< 
< %            (1)  (2)  (3)    (4)   (5)  (6)   (7)   (8)   (9)    (10) (11) (12) (13) (14) (15)
< % prjflt = [ dnum snum xtop1 ytop1 xbot1 ybot1 xbot2 ybot2 xtop2 ytop2 xctr yctr  ss   ds   ts ]
< if strcmpi(coord,'geo')
<     xx = prjflt(:,[3 5 7 9 11]);  yy = prjflt(:,[4 6 8 10 12]);
<     [lon,lat] = ckm2LLd(xx,yy,lon0,lat0,0);
<     newprjflt = [ prjflt(:,1:2) lon(:,1) lat(:,1) lon(:,2) lat(:,2) lon(:,3) lat(:,3) lon(:,4) lat(:,4) lon(:,5) lat(:,5) prjflt(:,13:15) ];
< end
< if strcmpi(coord,'local')
<     newprjflt = prjflt;
< end
---
> if ~isempty(pnt.crt), fclose(fpnt); end
243,244c268,294
< fprintf(fout,'#(1)name (2)dnum (3)snum (4)xtop1 (5)ytop1 (6)xbot1 (7)ybot1 (8)xbot2 (9)ybot2 (10)xtop2 (11)ytop2 (12)xctr (13)yctr (14)ss[m] (15)ds[m] (16)ts[m]\n'); 
< [ row,col ] = size(newprjflt);
---
> if ~isempty(prjflt12)
>     %              (1)  (2)  (3)    (4)   (5)  (6)   (7)   (8)   (9)    (10) (11) (12) (13) (14) (15)
>     % prjflt12 = [ dnum snum xtop1 ytop1 xbot1 ybot1 xbot2 ybot2 xtop2 ytop2 xctr yctr  ss   ds   ts ]
>     if strcmpi(coord,'geo')
>         xx = prjflt12(:,[3 5 7 9 11]);  yy = prjflt12(:,[4 6 8 10 12]);
>         [lon,lat] = ckm2LLd(xx,yy,lon0,lat0,0);
>         newprjflt12 = [ prjflt12(:,1:2) lon(:,1) lat(:,1) lon(:,2) lat(:,2) lon(:,3) lat(:,3) lon(:,4) lat(:,4) lon(:,5) lat(:,5) prjflt12(:,13:15) ];
>     end
>     if strcmpi(coord,'geo_polyconic')
>         xx = prjflt12(:,[3 5 7 9 11]); yy = prjflt12(:,[4 6 8 10 12]);
>         lon = zeros(size(xx));         lat = zeros(size(yy));
>         for ii=1:5
>             [lon(:,ii),lat(:,ii)] = xy_to_latlon(xx(:,ii),yy(:,ii),lon0,lat0);
>         end        
>         newprjflt12 = [ prjflt12(:,1:2) lon(:,1) lat(:,1) lon(:,2) lat(:,2) lon(:,3) lat(:,3) lon(:,4) lat(:,4) lon(:,5) lat(:,5) prjflt12(:,13:15) ];
>     end
>     if strcmpi(coord,'local')
>         newprjflt12 = prjflt12;
>     end
>     fprintf(fout,'#(1)name (2)dnum (3)snum (4)xtop1 (5)ytop1 (6)xbot1 (7)ybot1 (8)xbot2 (9)ybot2 (10)xtop2 (11)ytop2 (12)xctr (13)yctr (14)ss[m] (15)ds[m] (16)ts[m]\n'); 
>     [ row,col ] = size(newprjflt12);
>     for ii =1:row
>         name = flt_name12{ii};
>         flt  = newprjflt12(ii,:);
>         fprintf(fout,'%s %-3d %-3d %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-8.5f %-8.5f %-8.5f\n',name,flt);
>     end
> end
246,249c296,321
< for ii =1:row
<     name = flt_name{ii};
<     flt  = newprjflt(ii,:);
<     fprintf(fout,'%s %-3d %-3d %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-8.5f %-8.5f %-8.5f\n',name,flt);
---
> if ~isempty(prjflt34)
>     %              (1)  (2)  (3)    (4)   (5)  (6)   (7)   (8)   (9)    (10) (11) (12) (13) (14) (15)
>     % prjflt34 = [ dnum snum xtop1 ytop1 xbot1 ybot1 xbot2 ybot2 xtop2 ytop2 xctr yctr rake  rs   ts ]
>     if strcmpi(coord,'geo')
>         xx = prjflt34(:,[3 5 7 9 11]);  yy = prjflt34(:,[4 6 8 10 12]);
>         [lon,lat] = ckm2LLd(xx,yy,lon0,lat0,0);
>         newprjflt34 = [ prjflt34(:,1:2) lon(:,1) lat(:,1) lon(:,2) lat(:,2) lon(:,3) lat(:,3) lon(:,4) lat(:,4) lon(:,5) lat(:,5) prjflt34(:,13:15) ];
>     end
>     if strcmpi(coord,'geo_polyconic')
>         xx = prjflt34(:,[3 5 7 9 11]);  yy = prjflt34(:,[4 6 8 10 12]);
>         lon = zeros(size(xx));         lat = zeros(size(yy));
>         for ii=1:5
>             [lon(:,ii),lat(:,ii)] = xy_to_latlon(xx(:,ii),yy(:,ii),lon0,lat0);
>         end         
>         newprjflt34 = [ prjflt34(:,1:2) lon(:,1) lat(:,1) lon(:,2) lat(:,2) lon(:,3) lat(:,3) lon(:,4) lat(:,4) lon(:,5) lat(:,5) prjflt34(:,13:15) ];
>     end
>     if strcmpi(coord,'local')
>         newprjflt34 = prjflt34;
>     end
>     fprintf(fout,'#(1)name (2)dnum (3)snum (4)xtop1 (5)ytop1 (6)xbot1 (7)ybot1 (8)xbot2 (9)ybot2 (10)xtop2 (11)ytop2 (12)xctr (13)yctr (14)rake[deg] (15)rs[m] (16)ts[m]\n'); 
>     [ row,col ] = size(newprjflt34);
>     for ii =1:row
>         name = flt_name34{ii};
>         flt  = newprjflt34(ii,:);
>         fprintf(fout,'%s %-3d %-3d %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-12.5f %-11.5f %-8.2f %-8.5f %-8.5f\n',name,flt);
>     end
GTdef_slips.m
1,38c1,46
< function [ flt1_out,flt2_out,subflt_name,subflt_out ]...
<           = GTdef_slips(lb,ub,xx,flt1_num,flt1,flt2_num,flt2,...
<                         flt3_name,flt3_num,flt3,...
< 			flt4_name,flt4_num,flt4,...
< 			flt5_name,flt5_num,flt5)
< 
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %                             GTdef_slips				        %
< % Having the final values for the slips, put back the slips in the same	        %
< % format as the input file		  				        %
< %									        %
< % INPUT:					  		  	        %
< % Each fault has three (strike, dip, and tensile) components, so                %
< % slip_num = flt_num*3                                                          %
< %  xx   - final values for ss,ds,ts 	[slip_num*1]                            %
< %  lb   - lower bounds for ss,ds,ts 	[slip_num*1]                            %
< %  ub   - upper bounds for ss,ds,ts	[slip_num*1]			        %
< %  flt1 - [lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]     	%
< %  flt2 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]   	%
< %  flt3 - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]	%
< %  flt4 - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]%
< %  flt5 - [ ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns dlen slen ]		  	%
< %  subflt - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		  	%
< %									        %
< % OUTPUT:                                                                       %
< %  flt1_out - [lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]	%
< %             with ss, ds, ts replaced by inverted values			%
< %  flt2_out - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX]  %
< %             with ss, ds, ts replaced by inverted values			%
< % Full info about subfaults							%
< %  subflt_name - master-fault names						%
< %  subflt_out - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]			%
< %                                                                               %
< % first created by Lujia Feng Wed May  6 16:21:17 EDT 2009		        %
< % added fault5 lfeng Fri Dec 11 12:57:14 EST 2009				%
< % use cell array of strings for names lfeng Wed Dec  1 17:50:08 EST 2010	%
< % last modified by Lujia Feng Wed Dec  1 17:50:15 EST 2010			%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
---
> function [ flt1_out,flt2_out,flt3_out,flt4_out,subflt_out,subflt_name ]...
>           = GTdef_slips(lb,ub,xx,flt1,flt2,flt3,flt4,flt5,subflt_in)
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                                   GTdef_slips				                 %
> % Having the final values for the slips, put back the slips in the same	                 %
> % format as the input file		  				                 %
> %									                 %
> % INPUT:					  		  	                 %
> %----------------------------------------------------------------------------------------%
> % fault1 & fault2 have three (strike, dip, and tensile) components, so                   %
> % slip_num = flt_num*3                                                                   %
> %      xx  - final values for ss,ds,ts 	[slip_num*1]                                     %
> %      lb  - lower bounds for ss,ds,ts 	[slip_num*1]                                     %
> %      ub  - upper bounds for ss,ds,ts	[slip_num*1]			                 %
> % flt1.flt - [lon1 lat1 z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]        %
> % flt2.flt - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]      %
> %      subflt.flt - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]		  	 %
> %----------------------------------------------------------------------------------------%
> % fault3 & fault4 have two (rake and tensile) components, so                             %
> % slip_num = flt_num*2                                                                   %
> %      xx  - final values for rs,ts 	[slip_num*1]                                     %
> %      lb  - lower bounds for rs,ts 	[slip_num*1]                                     %
> %      ub  - upper bounds for rs,ts	[slip_num*1]			                 %
> % flt3.flt - [lon1 lat1 z1 z2 len str dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]  %
> % flt4.flt - [lon1 lat1 lon2 lat2 z1 z2 dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]%
> %      subflt.flt - [ dnum snum rake rs ts rake0 rakeX rs0 rsX ts0 tsX ]                 %
> %----------------------------------------------------------------------------------------%
> % flt5.flt - [ ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns dlen slen ]		         %
> %									                 %
> % OUTPUT:                                                                                %
> % flt1_out - [lon lat z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]	         %
> %             with ss, ds, ts replaced by inverted values			         %
> % flt2_out - [lon1 lat1 lon2 lat2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]      %
> %             with ss, ds, ts replaced by inverted values			         %
> % Full info about subfaults							         %
> % subflt_name - master-fault names						         %
> % subflt_out  - [ dnum snum ss ds ts ss0 ssX ds0 dsX ts0 tsX ]			         %
> %                                                                                        %
> % first created by Lujia Feng Wed May  6 16:21:17 EDT 2009		                 %
> % added fault5 lfeng Fri Dec 11 12:57:14 EST 2009				         %
> % used cell array of strings for names lfeng Wed Dec  1 17:50:08 EST 2010	         %
> % used structure lfeng Wed Feb 22 19:45:15 SGT 2012				         %
> % merged flt1 & flt3 and flt2 & flt4 lfeng Wed May  9 10:40:55 SGT 2012                  %
> % last modified by Lujia Feng Sun May 13 12:52:37 SGT 2012                               %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
49,53c57,79
< if flt1_num~=0
<     first = last+1;
<     last  = last+flt1_num*3;
<     slp1  = reshape(xx(first:last),[],3);
<     flt1_out = [ flt1(:,1:7) slp1 flt1(:,11:16) ];
---
> if flt1.num~=0
>     comp_num = 3;
>     for ii = 1:flt1.num
>         Nd = flt1.flt(ii,17); Ns = flt1.flt(ii,18); fltNum = Nd*Ns;
>         first = last+1; last = last+fltNum*comp_num;
> 	if fltNum==1
>             slp1 = reshape(xx(first:last),[],comp_num);
>             flt1_out = [ flt1.flt(ii,1:7) slp1 flt1.flt(ii,11:18) ];
> 	else
>             slp1 = reshape(xx(first:last),[],comp_num);
>             lb1  = reshape(lb(first:last),[],comp_num);
>             ub1  = reshape(ub(first:last),[],comp_num);
> 	    dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
> 	    slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
> 	    subflt     = [ dnum snum slp1 lb1(:,1) ub1(:,1) lb1(:,2) ub1(:,2) lb1(:,3) ub1(:,3) ];
> 	    subflt_out = [ subflt_out; subflt ];
> 
> 	    flt_name = flt1.name{ii};
>             name     = cell(fltNum,1);
>             for ii = 1:fltNum, name{ii} = flt_name; end
> 	    subflt_name = [ subflt_name; name ];   
> 	end
>     end
57,61c83,105
< if flt2_num~=0
<     first = last+1;
<     last  = last+flt2_num*3;
<     slp2  = reshape(xx(first:last),[],3);
<     flt2_out = [ flt2(:,1:7) slp2 flt2(:,11:16) ];
---
> if flt2.num~=0
>     comp_num = 3;
>     for ii = 1:flt2.num
>         Nd = flt2.flt(ii,17); Ns = flt2.flt(ii,18); fltNum = Nd*Ns;
>         first = last+1; last = last+fltNum*comp_num;
> 	if fltNum==1
>             slp2 = reshape(xx(first:last),[],comp_num);
>             flt2_out = [ flt2.flt(ii,1:7) slp2 flt2.flt(ii,11:18) ];
> 	else
>             slp2 = reshape(xx(first:last),[],comp_num);
>             lb2  = reshape(lb(first:last),[],comp_num);
>             ub2  = reshape(ub(first:last),[],comp_num);
> 	    dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
> 	    slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
> 	    subflt     = [ dnum snum slp2 lb2(:,1) ub2(:,1) lb2(:,2) ub2(:,2) lb2(:,3) ub2(:,3) ];
> 	    subflt_out = [ subflt_out; subflt ];
> 
> 	    flt_name = flt2.name{ii};
>             name = cell(fltNum,1);
>             for ii = 1:fltNum, name{ii} = flt_name; end
> 	    subflt_name = [ subflt_name; name ];   
> 	end
>     end
65,80c109,143
< if flt3_num~=0
<     for ii = 1:flt3_num
<         Nd = flt3(ii,17); Ns = flt3(ii,18); flt_num = Nd*Ns;
<         first = last+1;   last = last+flt_num*3;
<         slp3 = reshape(xx(first:last),[],3);
<         lb3 = reshape(lb(first:last),[],3);
<         ub3 = reshape(ub(first:last),[],3);
< 	dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
< 	slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
< 	subflt = [ dnum snum slp3 lb3(:,1) ub3(:,1) lb3(:,2) ub3(:,2) lb3(:,3) ub3(:,3) ];
< 	subflt_out = [ subflt_out; subflt ];
< 
< 	flt_name = flt3_name{ii};
<         name = cell(flt_num,1);
<         for ii = 1:flt_num, name{ii} = flt_name; end
< 	subflt_name = [ subflt_name; name ];   
---
> if flt3.num~=0
>    comp_num = 2;
>    for ii = 1:flt3.num
>         Nd = flt3.flt(ii,17); Ns = flt3.flt(ii,18); fltNum = Nd*Ns;
>         first = last+1;   last = last+fltNum*comp_num;
>         if fltNum==1
>             slp3 = reshape(xx(first:last),[],comp_num);
>             flt3_out = [ flt3.flt(ii,1:8) slp3 flt3.flt(ii,11:18) ];
>         else
>             slp3 = reshape(xx(first:last),[],comp_num);
>             lb3  = reshape(lb(first:last),[],comp_num);
>             ub3  = reshape(ub(first:last),[],comp_num);
>             dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
>             slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
>             % rake of master faults
>             rake  = flt3.flt(ii,8);  rlin  = ones(fltNum,1).*rake;
>             rake0 = flt3.flt(ii,11); rlin0 = ones(fltNum,1).*rake0;
>             rakeX = flt3.flt(ii,12); rlinX = ones(fltNum,1).*rakeX;
>             subflt = [ dnum snum rlin slp3 rlin0 rlinX lb3(:,1) ub3(:,1) lb3(:,2) ub3(:,2) ];
>             % subfault names
>             flt_name = flt3.name{ii};
>             name = cell(fltNum,1);
>             for ii = 1:fltNum, name{ii} = flt_name; end
>             subflt_name = [ subflt_name; name ];   
>     	    % rake of subfaults
>     	    sub_ind  = strcmpi(flt_name,subflt_in.name);
>             subflt3  = subflt_in.flt(sub_ind,:);
>             numT = size(subflt3,1);
>             for ii=1:numT
>                 dnumT = subflt3(ii,1); snumT = subflt3(ii,2);
>                 ind = (snumT-1)*Nd+dnumT;
>                 subflt(ind,[8 11 12])  = subflt3(ii,[8 11 12]);
>             end
>             subflt_out = [ subflt_out; subflt ];
>         end
85,100c148,182
< if flt4_num~=0
<     for ii = 1:flt4_num
<         Nd = flt4(ii,17); Ns = flt4(ii,18); flt_num = Nd*Ns;
<         first = last+1;   last = last+flt_num*3;
<         slp4 = reshape(xx(first:last),[],3);
<         lb4 = reshape(lb(first:last),[],3);
<         ub4 = reshape(ub(first:last),[],3);
< 	dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
< 	slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
< 	subflt = [ dnum snum slp4 lb4(:,1) ub4(:,1) lb4(:,2) ub4(:,2) lb4(:,3) ub4(:,3) ];
< 	subflt_out = [ subflt_out; subflt ];
< 
< 	flt_name = flt4_name{ii};
<         name = cell(flt_num,1);
<         for ii = 1:flt_num, name{ii} = flt_name; end
< 	subflt_name = [ subflt_name; name ];   
---
> if flt4.num~=0
>     comp_num = 2;
>     for ii = 1:flt4.num
>         Nd = flt4.flt(ii,17); Ns = flt4.flt(ii,18); fltNum = Nd*Ns;
>         first = last+1;   last = last+fltNum*comp_num;
> 	if fltNum==1
>             slp4 = reshape(xx(first:last),[],comp_num);
>             flt4_out = [ flt4.flt(ii,1:8) slp4 flt4.flt(ii,11:18) ];
> 	else
>             slp4 = reshape(xx(first:last),[],comp_num);
>             lb4  = reshape(lb(first:last),[],comp_num);
>             ub4  = reshape(ub(first:last),[],comp_num);
> 	    dlin = [ 1:Nd ]'; dmat = dlin(:,ones(Ns,1)); dnum = reshape(dmat,[],1);
> 	    slin = [ 1:Ns ];  smat = slin(ones(Nd,1),:); snum = reshape(smat,[],1);
> 	    % rake of master faults
> 	    rake  = flt4.flt(ii,8);  rlin  = ones(fltNum,1)*rake;
> 	    rake0 = flt4.flt(ii,11); rlin0 = ones(fltNum,1)*rake0;
> 	    rakeX = flt4.flt(ii,12); rlinX = ones(fltNum,1)*rakeX;
> 	    subflt = [ dnum snum rlin slp4 rlin0 rlinX lb4(:,1) ub4(:,1) lb4(:,2) ub4(:,2) ];
> 	    % subfault names
> 	    flt_name = flt4.name{ii};
>             name = cell(fltNum,1);
>             for ii = 1:fltNum, name{ii} = flt_name; end
> 	    subflt_name = [ subflt_name; name ];   
>     	    % rake of subfaults
>     	    sub_ind  = strcmpi(flt_name,subflt_in.name);
> 	    subflt4  = subflt_in.flt(sub_ind,:);
> 	    numT = size(subflt4,1);
> 	    for ii=1:numT
> 	        dnumT = subflt4(ii,1); snumT = subflt4(ii,2);
> 		ind = (snumT-1)*Nd+dnumT;
> 		subflt(ind,[8 11 12])  = subflt4(ii,[8 11 12]);
> 	    end
> 	    subflt_out = [ subflt_out; subflt ];
> 	end
105,108c187,190
< if flt5_num~=0
<     for ii = 1:flt5_num
<         Nd = flt5(ii,10); Ns = flt5(ii,11); flt_num = Nd*Ns;
<         first = last+1;   last = last+flt_num*3;
---
> if flt5.num~=0
>     for ii = 1:flt5.num
>         Nd = flt5.flt(ii,10); Ns = flt5.flt(ii,11); fltNum = Nd*Ns;
>         first = last+1;   last = last+fltNum*3;
117,119c199,201
< 	flt_name = flt5_name(ii,:);
<         name = cell(flt_num,1);
<         for ii = 1:flt_num, name{ii} = flt_name; end
---
> 	flt_name = flt5.name(ii,:);
>         name = cell(fltNum,1);
>         for ii = 1:fltNum, name{ii} = flt_name; end
GTdef_sm1d_2pctr_free.m
49c49
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_2pctr_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_3pbwd_rtdw_free.m
55c55
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pbwd_rtdw_free ERROR: Only one patch. No need to smooth!'); end
GTdef_sm1d_3pbwd_rtdw.m
50c50
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pbwd_rtdw ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_3pbwd_uprt_free.m
56c56
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pbwd_uprt_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_3pbwd_uprt.m
51c51
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pbwd_uprt ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_3pfwd_rtdw_free.m
55c55
< if nn==1, error('Only one patch. No need to smooth!');  end
---
> if nn==1, error('GTdef_sm1d_3pfwd_rtdw_free ERROR: only one patch. No need to smooth!');  end
GTdef_sm1d_3pfwd_rtdw.m
53c53
< if nn==1, error('Only one patch. No need to smooth!');  end
---
> if nn==1, error('GTdef_sm1d_3pfwd_rtdw ERROR: only one patch. No need to smooth!');  end
GTdef_sm1d_3pfwd_uprt_free.m
54c54
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pfwd_uprt_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_3pfwd_uprt.m
52c52
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_3pfwd_uprt ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_8pctr_rtdw_free.m
51c51
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_8pctr_rtdw_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm1d_8pctr_uprt_free.m
51c51
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm1d_8pctr_uprt_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm2d_free.m
51c51
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm2d_free ERROR: only one patch. No need to smooth!'); end
GTdef_sm2d.m
47c47
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_sm2d ERROR: only one patch. No need to smooth!'); end
GTdef_sm_fixed.m
diff: v2/GTdef_sm_fixed.m: No such file or directory
GTdef_sm_free.m
diff: v2/GTdef_sm_free.m: No such file or directory
GTdef_strain_free.m
49c49
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_strain_free ERROR: only one patch. No need to smooth!'); end
GTdef_strain.m
47c47
< if nn==1, error('Only one patch. No need to smooth!'); end
---
> if nn==1, error('GTdef_strain ERROR: only one patch. No need to smooth!'); end
GTdef_strike.m
18c18
< if col~=1&&row==1, error('Inputs have to be vectors for GTdef_strike'); end
---
> if col~=1&&row==1, error('GTdef_strike ERROR: inputs have to be vectors!'); end
GTdef_summary.m
GTdef_xsection.m
3,30c3,27
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %                               GTdef_xsection				  %
< % Calculate cross section of fault interface				  %
< %									  %
< % INPUT:					  		  	  %
< %  fault1 & fault3							  %
< %  flt = [ xx yy z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX ]     %
< %  fault2 & fault4							  %
< %  flt = [ x1 y1 x2 y2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX ]       %
< %  input coordinate is cartesian					  %
< %  dip is only used for fault3 & fault4					  %
< %  dipin = [ dip z1 z2 rows ]						  %
< %                                                                         %
< % OUTPUT: 								  %
< % [ index dip x1 z1 x2 z2 width rows ]                            	  %	
< %  xsect_name - master fault name [cell]				  %
< %  index    - position of each segment counting from surface  	  	  %
< %  dip      - dip angle [degree] (consider positive only)		  %
< %  x1,x2    - distance from fault vertical trace [m]                      %
< %  z1,z2    - shallowest and deepest depth of each segment [m]            %
< %  width    - surface apparent width of each segment [m]                  %
< %  rows     - num of patches on each segment                              %
< %                                                                         %
< % related functions:							  %
< % GTdef_project.m							  %
< % first created by Lujia Feng Thu Dec  2 02:22:28 EST 2010		  %
< % last modified by Lujia Feng Thu Dec  2 05:04:11 EST 2010		  %
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
---
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> %                               GTdef_xsection				        %
> % Calculate cross section of fault interface				        %
> %									        %
> % INPUT:					  		  	        %
> % flt1 = [xx yy z1 z2 len str dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]       %
> % flt2 = [x1 y1 x2 y2 z1 z2 dip ss ds ts ss0 ssX ds0 dsX ts0 tsX Nd Ns]         %
> % flt3 = [xx yy z1 z2 len str dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns] %
> % flt4 = [x1 y1 x2 y2 z1 z2 dip rake rs ts rake0 rakeX rs0 rsX ts0 tsX Nd Ns]   %
> % input coordinate is cartesian					                %
> % dipin = [ dip z1 z2 rows ]						        %
> %                                                                               %
> % OUTPUT: 								        %
> % [ index dip x1 z1 x2 z2 width rows ]                            	        %	
> %  xsect_name - master fault name [cell]				        %
> %  index    - position of each segment counting from surface  	  	        %
> %  dip      - dip angle [degree] (consider positive only)		        %
> %  x1,x2    - distance from fault vertical trace [m]                            %
> %  z1,z2    - shallowest and deepest depth of each segment [m]                  %
> %  width    - surface apparent width of each segment [m]                        %
> %  rows     - num of patches on each segment                                    %
> %                                                                               %
> % first created by Lujia Feng Thu Dec  2 02:22:28 EST 2010		        %
> % last modified by Lujia Feng Mon May 14 01:54:46 SGT 2012                      %
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
33c30,32
< if datanum~=16&&datanum~=18, error('need a n*16 or n*18 fault vector for GTdef_xsection'); end
---
> if datanum~=18  
>    error('GTdef_xsection ERROR: need a n*18 fault vector as input!'); 
> end
35c34
< if flt_type==1||flt_type==3
---
> if flt_type==1 || flt_type==3
37c36
< elseif flt_type==2||flt_type==4
---
> elseif flt_type==2 || flt_type==4
40c39
<    error('fault type is wrong!');
---
>    error('GTdef_xsection ERROR: fault type is wrong!');
44c43
<    xsect_name = flt_name;					% flt_name - cell array for fault 1 & 2
---
>    xsect_name = flt_name;					% flt_name - cell array
49c48
< elseif flt_type==3||flt_type==4
---
> else
52c51
<    for ii = 1:dipnum, xsect_name{ii} = flt_name; end		% flt_name - strings for fault 3 & 4
---
>    for ii = 1:dipnum, xsect_name{ii} = flt_name; end		% flt_name - strings
55c54
<    dipin = sortrows(dipin,2);		% order from surface down
---
>    dipin = sortrows(dipin,2);		                        % order from surface down
62,63d60
< else
<    error('fault type 1 & 2 can not have different dips!');
LL2ckmd.m
LL2ckm.m
diff: v2/LL2ckm.m: No such file or directory
